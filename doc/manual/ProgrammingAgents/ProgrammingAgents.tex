\chapter{Programming Agents} \label{chap:programmingAgents}
%MUY IMPORTANTE. Esta parte está destinada al programador de agentes que no tiene interés alguno acerca de cómo poner la plataforma en marcha y mucho menos sobre cómo están implementadas las cosas por dentro. En cada sección referencias con una breve descripción qué ejemplos están disponibles.
%


%\section{Development environment}\label{sec:develEnvironment}
%Todo lo necesario para configurar eclipse para poder desarrollar agentes Magentix2.
%Joan y Ricard consideran redundante su contenido

%==================================================================
%================== SEGUNDA SECCIÓN ===============================
%==================================================================
\section{Basic classes for building agents: BaseAgent and SimpleAgent}

\subsection{BaseAgent}\label{sec:BaseAgent}

In order to create a basic Magentix2 agent, it is necessary to define a class which extends the class:\\ \lstinline|es.upv.dsic.gti_ia.core.BaseAgent|. A unique identifier (with a new instance of AgentID class) must be associated to the agent and it is also necessary to  implement the logic of the agent in the \lstinline|execute()| method.

The following code shows how to implement a new BaseAgent class named SenderAgent. This agent only shows its name by the screen:

\begin{lstlisting}
import es.upv.dsic.gti_ia.core.ACLMessage;
import es.upv.dsic.gti_ia.core.AgentID;
import es.upv.dsic.gti_ia.core.BaseAgent;

public class SenderAgent extends BaseAgent {

  public SenderAgent(AgentID aid) throws Exception {
	super(aid);
  }

  public void execute() {
	System.out.println("Executing, I'm " + getName());
	
  }

}
\end{lstlisting}

\subsection{SimpleAgent}\label{sec:SimpleAgent}
In order to create a simple Magentix2 agent, it is required to define a class which extends the class: \lstinline|es.upv.dsic.gti_ia.core.SingleAgent|. It is a extended class from BaseAgent.

The SingleAgent defines a new message reception method (receiveACLMessage()) that performs blocking reception. It receives a new message in blocked mode. Then, when the agent retrieves the message, it is removed form the head of the agent's message queue.

The following code shows how to implement a new singleAgent with the receiveACLMessage() method:
\begin{lstlisting}
public void execute() {
  /**
  * This agent has no definite work. Wait infinitely the arrival of
  * new messages.
  */
  try {
	/**
	 * receiveACLMessage is a blocking function.
	 * its waiting a new ACLMessage
	 */
	ACLMessage msg = receiveACLMessage();

	System.out.println("Mensaje received in " + this.getName()
		+ " agent, by receiveACLMessage: " + msg.getContent());
  } catch (Exception e) {
	logger.error(e.getMessage());
	return;
  }
}

\end{lstlisting}
\subsection{Initialization Tasks} 
Magentix2 platform uses log4j as a logging facility. It was developed by the  Apache's Jakarta Project\footnote{http://jakarta.apache.org/}. Its speed and flexibility allows log statements to remain in shipped code while giving the user the ability to enable logging at runtime without modifying any of the application binaries. 

Log4j must be initialized inside the \lstinline|main()| method of each Java application as follows:
 
\begin{lstlisting}
DOMConfigurator.configure("configuration/loggin.xml");

Logger logger = Logger.getLogger(Run.class);
\end{lstlisting}
 
The file logging.xml \footnote{This file is located in directory bin/configuration of the Magentix2 installation.} is used to specify what level of log messages are written to the log files for each component. Moreover, Log4j allows logging requests to print to multiple destinations called appenders. 


Two appenders predefined for Magentix2 are showed in \ref{fig:Appender1} and \ref{fig:Appender2} figures. Specifically, the appender 1 (figure \ref{fig:Appender1}) indicates a file as the standard output. The appender 2 (figure \ref{fig:Appender2}) indicates the console as the standard output. Please, to learn more about appenders refer to: \url{http://logging.apache.org/log4j/1.2/index.html}


\begin{figure}
\begin{codigo}
<appender name="File" class="org.apache.log4j.FileAppender">
	<param name="File" value="logs/Magentix2.log"/>
	<layout class="org.apache.log4j.PatternLayout">
	    <param name="ConversionPattern" value="%t %-5p %c{2} 
		   - %m%n"/>
	</layout>
</appender>
\end{codigo}
\caption{Appender 1} 
\label{fig:Appender1}
\end{figure}


\begin{figure}
\begin{codigo}
<appender name="Console" class="org.apache.log4j.ConsoleAppender">
	<layout class="org.apache.log4j.PatternLayout">
	<param name="ConversionPattern" value="%d %-5p [%t] %C{2}
		(%F:%L) - %m%n"/>
	</layout>
</appender>
\end{codigo}
\caption{Appender 2} 
\label{fig:Appender2}
\end{figure}




\subsection{Connecting to the Qpid Broker}
\label{subsec:connecting}
A connection to the Qpid broker must be established before launching any agent. This connection will be used by agents to communicate with each other. At this point, it is  assumed that users have a Qpid broker running properly and the agents are launched without security.To employ connections with the security mode enabled, please refer to section \ref{sec:securityenable}.

The following parameters must be specified in any connection to the broker:

\begin{itemize}
\item$<$QpidHost$>$ the host (or ip address) to connect to (defaults to 'localhost'). 
\item$<$QpidPort$>$ refers to the port to connect to (defaults to 5672). 
\item$<$QpidVhost$>$ allows an Qpid 'virtual host' to be specified for the connection (defaults to 'test'). 
\item$<$QpdidUser$>$ user name to access Qpid.
\item$<$QpidPassword$>$  password to access Qpid.
\item$<$QpidSSL$>$ indicates if  SSL is used during the connection (its value is always false when security is not enabled).
\end{itemize}

There are three different ways to establish a connection to the Qpid broker  using the \lstinline|connect()| method implemented in the  \lstinline|es.upv.dsic.gti_ia.core.AgentsConnection |class:
 

 

\begin{itemize}
\item Calling \lstinline|connect()| without parameters. In this case the parameters are gathered from the Settings.xml \footnote{This file is located in the directory bin/configuration of the Magentix2 installation.} file. For example:\\ 
\begin{center}
 \lstinline|AgentsConnection.connect();|
\end{center}
 

Thus, it is possible to specify the connection parameters inside the Settings.xml file. Note that if all the parameters are not specified in the Settings.xml file, it is not feasible to use the \lstinline|connect()| method without parameters.

An example of the Settings.xml  file could be:

\begin{codigo}
   <!-- Properties qpid broker -->
    <entry key="host">localhost</entry>
    <entry key="port">5672</entry>
    <entry key="vhost">test</entry>
    <entry key="user">guest</entry>
    <entry key="pass">guest</entry>
    <entry key="ssl">false</entry>
\end{codigo}

\item Specifying all the parameters when calling \lstinline|connect()|. Example:
\begin{center}
\lstinline|AgentsConnection.connect("localhost",5672,"test","guest","guest",false);|
\end{center}

\item Specifying only the $<$qpidhost$>$ parameter, leaving the rest as default parameters. In the current example case the default values will be  (5672,"test","guest","guest",false) respectively. Example:
\begin{center} 	
\lstinline|AgentsConnection.connect("host.domain");|
\end{center}
\end{itemize}

\subsection{Running Agents}
Once agents are implemented, they can be instantiated and launched. Please note that the platform do not allow different agents with the same name.

In order to instantiate an agent, an agent ID must be also created as follows: 
\begin{itemize}
 \item AgentID(String Identifier), where Identifier is the agent name. 
\end{itemize}

 
Examples of creating a new instantiation:

\begin{lstlisting}
SenderAgent agent1 = new SenderAgent(new AgentID("sender"));
		
ConsumerAgent agent2 = new ConsumerAgent(new AgentID("consumer"));
\end{lstlisting}


Once instantiated, agents can be launched by calling to their \lstinline|start()| method. 


Examples:

\begin{lstlisting}
    agent1.start();
    agent2.start();
\end{lstlisting}

\subsection{Optional Methods} 
The \lstinline|init()| and \lstinline|finalize()| methods are also defined in the  \lstinline|es.upv.dsic.gti_ia.core.BaseAgent| class. These methods are automatically executed before and after the \lstinline|execute()| method. The programmer can  overwrite  these methods in order to include initialization or termination tasks.


\subsection{Running Examples}

In the examples folder of the Magentix2 package there are some basic examples of Magentix agents: 
\begin{itemize}

 \item BaseAgent\_Example: this is an example of sender/consumer agents. The sender agent sends an ACLMessage to the consumer agent. When the ACLMessage arrives to the consumer agents, a message is shown.
 
 \item SingleAgent\_Example: this is an example of sender/consumer agents. The sender agent sends an ACLMessage to the consumer agent. When the ACLMessage arrives to the consumer agents, a message is shown.
The consumer is in blocked state waiting the message.

\end{itemize}

%==================================================================
%================== TERCERA SECCIÓN ===============================
%==================================================================
\section{Agent Communication}
%La clase ACLMessage. Envío y recepción de mensajes desde las clases básicas. Consideraciones sobre el envío/recepción con agentes externos %usando FIPA-ACL sobre http.



In Magentix2, each agent has a message queue on the Qpid broker, where other agents can post messages addressed to her.
The Figure \ref{fig:MessagesExchangeQpid} illustrates how a sender agent posts a message in a queue. Then, a consumer agent is able to read this message.
 \begin{figure}
 \centering
\includegraphics[width=\textwidth]{ProgrammingAgents/images/MessagesExchangeQpid.png}
\caption[Messages exchange thought QPID Broker in Magentix2]{Messages exchange thought QPID Broker in Magentix2 } \label{fig:MessagesExchangeQpid} 
\end{figure}

\subsection{{FIPA} {ACL} Language}
Messages exchanged by Magentix2 agents have the format specified by the ACL language defined by the FIPA\footnote{\url{http://www.fipa.org}}  international standard for agent interoperability. This format comprises a number of fields, such as:
\begin{itemize}
	\item Sender of the message. 
	\item A list of receivers.
	\item Performative: REQUEST, INFORM, QUERY\_IF, CFP, PROPOSE, ACCEPT\_PROPOSAL, REJECT\_PROPOSAL, etc.
	\item Content. 
	\item Content Language. 
	\item Content Ontology. 
	\item Conversation-id, reply-with, in-reply-to, reply-by, etc.
	
\end{itemize}

A message in Magentix2 is implemented as an instance of the \url{es.upv.dsic.gti_ia.core.ACLMessage} class that provides get and set methods for handling all the fields of a message. 

\subsection{Sending Messages}

To send a message to another agent the programmer must fill the fields of an ACLMessage object and then call the send() method of the \url{es.upv.dsic.gti_ia.core.BaseAgent} class.
 

The code below informs an agent whose identifier is receiver with the text: "Hello I'm sender".
\begin{lstlisting}[style=Java]
	
		// Building a ACLMessage 
		ACLMessage msg = new ACLMessage(ACLMessage.REQUEST);
		msg.setReceiver(receiver);
		msg.setSender(this.getAid());
		msg.setLanguage("ACL");
		msg.setContent("Hello, I'm " + getName());

		
		// Sending a ACLMessage	 
		send(msg);

\end{lstlisting}

\subsection{Receiving Messages}

Whenever a message is posted in the message queue of an agent, this agent is notified by the \textit{onMessage(ACLMessage msg)} method. This method allows agents to receive any message automatically. Note that agents can also keep all received messages in an internal list (or queue) for reading them later.
Agent programmers must overwrite the  \textit{onMessage} method when  implementing a new agent, in order to process received messages. For instance:

\begin{lstlisting}[style=Java]
public void onMessage(ACLMessage msg) {
           
     // When a message arrives, it is shown in the screen
            
     logger.info("Mensaje received in " + this.getName() + " agent, by onMessage: " + msg.getContent());
}
\end{lstlisting}
\subsection{External Communication}

An external agent is any agent not running over Magentix2  platform but communicating to any of the agents running on Magentix2. In this sense, Magentix2 implements the FIPA-HTTP message transport protocol  by means of two special Magentix2 agents:
\begin{itemize}
\item \textit{BridgeAgentInOut}: this agent is implemented in the  \url{es.upv.dsic.gti_ia.core.BridgeAgentInOut} class. This agent is in charge of receiving all the messages sent by Magentix2 agents in which the recipient are agents running on another platform (that uses \textit{http} as communication protocol). Then, the \textit{BridgeAgentInOut} encapsulates the entire message and sends it via \textit{http}. 

\item \textit{BridgeAgentOutIn}: the implementation of this agent can be found in the \url{es.upv.dsic.gti_ia.core.BridgeAgentOutIn} class. The  \textit{BridgeAgentOutIn} routes messages from external agents (received via \textit{http}) to Magentix2 agents. Therefore, BridgeAgentOutIn decodes the http message received and creates an ACLMessage message. After that, \textit{BridgeAgentOutIn} sends the new created message to the recipient's mailbox. 
\end{itemize}

%It is necessary to instantiate and launch the \textit{BridgeAgentInOut} and the \textit{BridgeAgentOutIn} agents to allow external communication. It can be done by means of the script \textit{Launch-MagentixAgents.sh}, which can be found inside the Magentix2 installation directory in the path  magentix2/bin. Specifically, the commands needed are:
%\begin{verbatim}
%$ cd  bin 
%$ sh Launch-MagentixAgents.sh
%\end{verbatim}

It should be notice that the \textit{BridgeAgentInOut} and the \textit{BridgeAgentOutIn} agents must be launched and instantiate to allow external communication. This is made together with the rest of platform services and platforms agents by means of the \textit{Start-Magentix.sh} command (explained in section \ref{sec:InstallMagentix2DistDirectory}. %los agentes se lanzarán en localhost, y el agente pasarela OutIn escuchará por el puerto 8081 
Thus, the \textit{BridgeAgentInOut} and the \textit{BridgeAgentOutIn} agents would be launched at localhost, and the agent \textit{BridgeAgentOutIn} would be listening in the 8081 port. For other configurations, please refer to section \ref{sec:AdminRunningBridgeAgents}



%Of course, it is also possible create and launch these agents separately, creating them and calling their execution methods inside the user source code ( for example, in the main function). The following code shows how it can be done:
%
%\begin{lstlisting} 
%/** * Instantiating a BridgeAgentInOut SingleAgent
%/
%BridgeAgentInOut agenteInOut = new BridgeAgentInOut(new AgentID(
%"BridgeAgentInOut", "qpid", "hostname.domain", "5000"));
%/* * Instantiating a BridgeAgentOutIn SingleAgent
%*/
%BridgeAgentOutIn agenteOutIn = new BridgeAgentOutIn(new AgentID(
%"BridgeAgentOutIn", "qpid", "hostname.domain", "5000"));
%
%/** * Execute the agents
%*/
%agenteInOut.start();
%agenteOutIn.start();
%\end{lstlisting}




Inside Magentix2, external agents are identified (to send messages to them) by means of an \textit{http} address that must be used when creating the corresponding AgentID. For instance, the following example shows the code which could be added into the \textit{execute} method of a Magentix2 agent to send a Request message to another agent running into a JADE platform. 

\begin{lstlisting}
AgentID receiver = new AgentID(); 

//JADE default parameters.       
receiver.name = "AgentName@hostname:1099/JADE";

//Host in which the JADE agent is running  
receiver.host = "hostname.domain";  

//JADE default port for ACC                    
receiver.port = "7778"; 

//Default protocol                             
receiver.protocol = "http";                      

/**
 * Building a ACLMessage         */       
 
 //New Request message
 ACLMessage msg = new ACLMessage(ACLMessage.REQUEST); 
 //The JADE agent is added as a receiver of the message 
 msg.setReceiver(receiver); 
 
 //The Magentix2 agent sends the message													       
 send(msg); 																				
\end{lstlisting}

In a similar way, the following example shows how an external JADE agent sends a message to a MAgentix2 agent from the JADE platform (JADE source code):

 
\begin{lstlisting}
AID receiver = new AID();

 //agentname@hotsname of the Magentix2 platform in which the agent is running      
receiver.setName("consumer@hostname");

/Host in which the BridgeAgentOutIn agent is been executed and the port 
//in which it is listened             
receiver.addAddresses("http://host.domain:8081"); /

//Creation of a Request Message
ACLMessage msg = new ACLMessage(ACLMessage.REQUEST);   

 //Addition of the receiver of the message         
msg.addReceiver(receiver);

//Sending the message
send(msg);																						
\end{lstlisting}

%==================================================================
%================== CUARTA SECCIÓN ================================
%==================================================================
\section{Basic conversational agents: QueueAgents}

Magentix2  supports the set of basic interaction protocols defined by FIPA. Thereby, agents can communicate to each other by means of different protocols explained in this section.

Each implemented protocol provides the basic message exchange between two agents for a given type of conversation (a request, a query, etc.). In order to implement these protocols, a new agent template called \emph{QueueAgent} has been defined. This template extends \emph{BaseAgent} and can be found in the package  \lstinline|es.upv.dsic.gti_ia.architecture|. The figure  \ref{fig:Qarchitecture} shows a UML class diagram for the  QueueAgent class.


\begin{figure}[!ht]
	\centering
	\includegraphics[width=\textwidth]{ProgrammingAgents/images/QueueAgentArchitecture}
	\caption{Diagram for the  QueueAgent class}
	\label{fig:Qarchitecture}
\end{figure}

In order to use protocols, agents must extend the QueueAgent class and redefine its constructor. For instance: 

\begin{lstlisting}
	import es.upv.dsic.gti_ia.architecture.QueueAgent;
	import es.upv.dsic.gti_ia.core.AgentID;

	public class agent extends QueueAgent {

	public agent(AgentID aid) throws Exception {
		super(aid);
	}
\end{lstlisting}


\subsection{Communication Protocols on Magentix2 platform.}
Three interaction protocols specified by FIPA (Request, Query and the Contract-Net) have been implemented in the Magentix2 basic conversational protocol. For this purpose, a set of classes have been implemented, and they can be found into the \lstinline|es.upv.dsic.gti-ia.architecture package.|
Within all of the protocols implemented, agents can play both initiator and responder role. These roles implement different behaviors. The initiators  are executed once, while responders are executed cyclically, so they will return to its initial state after reaching the final one.
The set of classes in the \lstinline|es.upv.dsic.gti-ia.architecture| package have been designed so that programmers do not need to deal with neither message sending nor protocol status monitoring. Thus, programmers only have to define what should be done in each state of the protocol and prepare messages before sending. The actions performed in each state are defined by handlers for initiator roles and preparers for responder roles.

\begin{itemize}
 


 \item	Handlers:
A handler is a method which is executed when a specific protocol state is reached for agents playing initiator roles. Each protocol has a handler per each state it can reach. Although there are default handlers (which do nothing) defined for each protocol, agent programmers can overload each handler with the functionality they require in each protocol state.
\begin{lstlisting}
	protected void handleAgree(ACLMessage agree) {
		logger.info("Good news");
		}
\end{lstlisting}
 \item	Preparers:
Preparers are similar to handlers but are executed when the agent plays the responder role in the protocol. 
Messages must be filled carefully because leaving a field empty can interrupt the entire protocol.  Therefore, we encourage the use of the method \lstinline|createReply()| included in ACLMessage messages. This method produces a new answer to the original message with the required fields covered, so only required ones need to be modified.
\begin{lstlisting}
protected ACLMessage prepareResultNotification(ACLMessage inmsg, 
					      ACLMessage outmsg) {

	    ACLMessage msg = inmsg.createReply();
	    return (msg);
	}
\end{lstlisting}
\end{itemize}
\subsection{How to implement a FIPA-Protocol}
Following, some explanations of how  the  FIPA-Protocols proportionated by Magentix2 have been implemented are proportioned, in order to illustrate how new protocols could be implemented.

\subsubsection{FIPA-Request}
This protocol allows agents to request other agents to perform an action and it is identified in the protocol parameter of the message with the FIPA-request value. The messages exchanged are: 
\begin{enumerate}


\item \textbf{Request:} which contents the request. 
\item \textbf{Agree or Refuse:} when the agent accepts the request or rejects it respectively.
\item \textbf{Failure:} when the previous message was an Agree and an error happened during the process.
\item \textbf{Inform-done:} when the previous message was an Agree and the process ends successfully.
\item \textbf{Inform-result:} when the previous message was an Agree, the process ends successfully and there is also a result.
	
The protocol early terminates if:
\begin{itemize}
\item The initiator send  to the responder a message explicitly CANCEL  instead of the next initiator. 
\item The responder responds negatively to REFUSE, NOT\_UNDERSTOOD or FAILURE performative.
\end{itemize}
\end{enumerate}

	The following code shows how to implement a responder rol:

 	 \begin{lstlisting}   
	public class Responder extends FIPARequestResponder {

	public Responder(QueueAgent agent) {
	super(agent,new MessageTemplate(InteractionProtocol.FIPA_REQUEST));

	}

	protected ACLMessage prepareResponse(ACLMessage msg) {
	protected ACLMessage prepareResultNotification
					(ACLMessage inmsg, ACLMessage outmsg) 	{}
\end{lstlisting}
     	The following code shows how to implement an initiator rol:
	 \begin{lstlisting} 
	

	class Initiator extends FIPARequestInitiator {


	public Initiator(QueueAgent a, ACLMessage msg) {
		super(a, msg);
	}

	protected void handleAgree(ACLMessage agree) {
	protected void handleRefuse(ACLMessage refuse) {
	protected void handleNotUnderstood(ACLMessage notUnderstood) {
	protected void handleInform(ACLMessage inform) {
	protected void handleFailure(ACLMessage failure) {
\end{lstlisting}


\subsubsection{FIPA-Query}
This protocol allows agents to request other agents: to query whether a particular proposition is true or false (query-if) and to query for some identified objects (query-ref). Depending on the type of request, the messages can be:  

\begin{enumerate}

\item  \textbf{Query-If or Query-Ref:} it contents the request. 
\item  \textbf{Agree:} when the agent accepts the request. 
\item  \textbf{Refuse:} in the case the agent rejects the request.
\item  \textbf{Failure:} in the case an error occurred during the process
\item  \textbf{Inform-T/F:} when the previous message was an Agree and the first message was a Query-If.
\item  \textbf{Inform-Result:} when the previous message was an Agree and the first message was a Query-Ref.
\end{enumerate}


 \subsubsection{FIPA-Contract-Net}
The classes ContractNet implements the behaviour of the protocol of the same name, whose operation is: the initiator sends a proposal to several responders, then evaluates their answers and finally chooses the preferred one (or no one). The messages exchanged are: 
\begin{enumerate}
\item \textbf{CFP (Call For Proposal):} it specifyes  the action to carry out and, when it is appropriate, the conditions on the performance.
\item \textbf{Refuse:} when responders reject their participation.
\item \textbf{Not-Understood:} when there were failings in the communication.
\item \textbf{Propose:} when a responder makes proposal to the initiator. 
\item \textbf{Reject-Proposal:} in the case the initiator evaluates a proposal and reject it 
\item \textbf{Accept-Proposal:} when the initiator evaluates a proposal and accepts it, sending this type of message to accept them. 
\item \textbf{Failure:} responder send this type of message when their proposals were accepted and something wrong happened.
\item \textbf{Inform-Done:} this messages is sended by responders when their proposals were accepted and the action was performed successfully.
\item \textbf{Inform-Results:} this message is sended by responders when their proposals were accepted and they need to inform about the results of the operation performed. 
\end{enumerate}
The initiator (ContractNetInitiator) has two main methods: the handlePropose method, which is called each time a response is received and the handleAllResponses method, which is called when all responses are received or the timeout is exceeded.  The responder agent has the handleAcceptProposal and handleRejectProposal methods, which are called depending on whether the proposal was accepted or not, and their main characteristic is that both of them receive  as input parameters all the messages exchanged by both agents so far. 


\subsection{Running QueueAgents}
Once defined the protocol, we have to create a new instance and add it to the agent tasks (method addTask). In the initiator role, it is necessay to create and fill in the appropriate message for the desired protocol. 

For example,  for the protocol request: 
\begin{lstlisting}   
	ACLMessage msg = new ACLMessage(ACLMessage.REQUEST);
	msg.setReceiver(new AgentID("HospitalAgent"));
	msg.setProtocol(InteractionProtocol.FIPA_REQUEST);
	msg.setContent("accident to " + "10" + " km");
	msg.setSender(this.getAid());

	this.addTask(new FIPARequestInitiator(this,msg));
\end{lstlisting}
For the responder, it is needed to create a template with the desired protocol: 
\begin{lstlisting}   
	MessageTemplate template = new MessageTemplate(
				InteractionProtocol.FIPA_REQUEST);

	this.addTask(new FIPARequestResponder(this,template));
\end{lstlisting}
When a task is added , a new thread is created for the agent. Therefore, it is necessary to be careful which the main thread of the agent is not finished. For instance,  a monitor can be used to wait for the completion of the roles: 
\begin{lstlisting}   
	import es.upv.dsic.gti_ia.architecture.Monitor;

	private Monitor monitor = new Monitor();

	protected void execute() {
				.
				.
				.
		this.addTask(new FIPARequestInitiator(this, msg));
		monitor.waiting();
	}
\end{lstlisting}

\subsection{Examples}

In the examples folder of the Magentix2 packages there are some basic interaction protocols examples: 
\begin{itemize}

\item \textbf{Request:} this example follows the FIPA Request protocol. In this example two agents are created. One agent plays the responding role by simulating a hospital which listens emergency calls. The other agent simulates an accident witness. When the witness see an accident sends a help message to the hospital. The hospital checks if the accident is placed in the action area and if it could attend it.

\item \textbf{ContractNet:} this is an example where the FIPA ContractNet protocol is followed. In this example, two types of agents are created. One type of agents plays the responding role (dealers). The other type, a single agent, plays the initiator role (buyer). The buyer sends a purchase request to each dealer agent. Each dealer agent answers the bid according her preferences and waits for the buyer decision. The buyer chooses one offer and informs the specific dealer and also sends a reject message to the rest of the dealers.
\end{itemize}

%==================================================================
%================== QUINTA SECCIÓN ================================
%==================================================================
\section{Advanced conversational agents: CAgents}\label{sec:CAgents}
CAgents facilitate the use and management of conversations. CAgents use CFactories and CProcessors, these two components control ongoing conversation and create new ones. On the one hand, CFactories act as Interaction Protocols (IPs) and are in charge of creating new CProcessors. On the other hand, CProcessors act as instances of CFactories, that is conversations. CFactories have a graph made up of states and arcs. A graph specifies the sequence of actions that a conversation which is following that protocol has to take. Each state represents a specific action, and each arc represents a possible transition between two states. A collection of states (actions) has been defined:
\begin{itemize}
\item \emph{Begin}: This state represent that the agent starts the conversation. 
\item \emph{Final}: This state represent that the agent ends the conversation.
\item \emph{Send}: In this state the agent sends a message. 
\item \emph{Wait}: When a agent reaches this state, the conversation halts until a message is assigned to the conversation. 
Then, according to the type of the arrived message, an specific subsequent \emph{Receive} state is executed. The type of the message is defined by its header. 
\item \emph{Receive}: This state must be preceded by a \emph{Wait} state. In this state the agent receives a message. Each \emph{Receive} state manages messages with a specific set of headers.
\end{itemize}
CFactories can be initiator or participant, the use of each type depends on the role the agent will play in the conversations. On the one hand, initiator CFactories start conversations when directed by agent's logic, i.e. they do not depend on external stimuli in order to start a new conversation. On the other hand, participant CFactories start a CProcessor when they receive a message with the appropriate message parameters. These parameters are specified using a message filter associated to the participant CFactory.

The transition between two states occurs when the agent receives or sends a message related to that specific conversation. CProcessors are in charge of making these transitions as well as executing the actions of each state of the conversation.

When a CProcessor is created, it has a copy of the graph specified in the CFactory that created the CProcessor. During the conversation, the CProcessor will execute the actions of the state the conversation is currently at, and it will change the state of the conversation as new messages are sent and received. As each CProcessor has its own graph, an ongoing conversation can be dynamically modified without affecting the IP the conversation is following or other ongoing conversations which follows that IP.

In figure \ref{img:requestIni} an example of an IP transformed into a graph associated to a CFactory is shown. This IP corresponds to the \textit{FIPA Request Interaction Protocol} \cite{fipa02} for the initiator role. 

\begin{figure}
\centering
\includegraphics[scale=0.5]{ProgrammingAgents/images/fiparequestIni}
\caption{CFactory for FIPA Request Interaction Protocol for the initiator agent}
\label{img:requestIni}
\end{figure}

In figure \ref{img:global} a global view of a CAgent is shown. In this figure the agent shown has three CFactories, two of them are participant and the third one is initiator. At the same time the agent has two ongoing CProcessors that manage two conversations ``Conv1'' and ``Conv2''. The first one has been created by the initiator CFactory 1, the other one by the participant CFactory 1. The initiator CFactory 1 created the CProcessor managing ``Conv1'' because the execution of the agent dictates that, instead the ``Conv2'' was created by the participant CFactory 1 because the agent received an \emph{inform} message. From this moment on, every message with the message parameter \emph{conversation\_id} set to ``Conv1'' will be automatically assigned to the CProcessor managing that conversation. The same will occur with ``Conv2'' messages. If in the future the agent receives a \emph{request} message, the participant CFactory 2 will create a new CProcessor which will manage the new conversation. Other possibility is that the  agent receives an \emph{inform} message with an unknown \emph{conversation\_id}. In that case, the participant CFactory 1 will create a new CProcessor and two conversations which follows the same IP. This conversations will be managed simultaneously, the previous ``Conv2'' and the new conversation. For more information about CAgents please refer to \cite{Fogues10}.

\begin{figure}
\centering
\includegraphics[scale=0.37]{ProgrammingAgents/images/global}
\caption{Global view of a CAgent}
\label{img:global}
\end{figure}

In the next sections some examples of CAgents are explained. All the code of these examples are available in the examples directory of Magentix2 platform.

\subsection{``Hello World'' CAgent}
The code shown in this section corresponds to the code located in examples/src/myFirstCAgent/HelloWorldAgent.java. In the code below, the method \texttt{execution} is where the user has to implement the main code of the agent. In this ``hello world'' agent the main behaviour of the agent is just to say ``hello world''. The method \texttt{finalize} is executed when the agent is just about to finish its execution, thus, here is where the user has to implement ending actions of the agent.
\begin{lstlisting}[style=Java]
class HelloWorldAgentClass extends CAgent {
   public HelloWorldAgentClass(AgentID aid) throws Exception {
      super(aid);
   }

   // The platform starts a conversation with each agent that has been just created
   // by sending it a welcome message. This sending creates the first CProcessor
   // of the agent. In order to manage this message the user must implement 
   // the execution method defined by the class CAgent, this method will
   // be executed by the first CProcessor.
   // It is also in this method where all other actions and behaviours of the
   // agent has to be implemented

   protected void execution(CProcessor myProcessor, ACLMessage welcomeMessage) {
      System.out.println(myProcessor.getMyAgent().getName()
	 + ": the welcome message is " + welcomeMessage.getContent());
      System.out.println(myProcessor.getMyAgent().getName()
	 + ":  inevitably I have to say hello world");
      // ShutdownAgent method initialize the process which will finalize the
      // active conversations of the agent. When this process ends, the platform
      // sends a finalize message to the agent.
      myProcessor.ShutdownAgent();
   }

   // In order to manage the finalization message, the user has to
   // implement the finalize method defined by the CAgent class.
   protected void finalize(CProcessor myProcessor, ACLMessage finalizeMessage) {
      System.out.println(myProcessor.getMyAgent().getName()
	 + ": the finalize message is " + finalizeMessage.getContent());
   }
}  
\end{lstlisting}

\subsection{Creating a CFactory and its CProcessor}
\label{subsec:cprocessor}
The code shown in this section corresponds to the code located in examples/src/myFirstCProcessorFactories/Harry.java. The CFactory shown here corresponds to the one shown in figure \ref{img:cfactory}.

\begin{figure}[!h]
\centering
\includegraphics[scale=0.6]{ProgrammingAgents/images/cfactory}
\caption{myFirstCProcessorFactories example}
\label{img:cfactory}
\end{figure}

In order to create a CProcessor, first it is necessary to define the states and the transitions that compose the graph associated to the CProcessor. This can be done in the execution method of the agent. Every conversation starts with a \textit{begin} state called ``BEGIN''. In the first line of the code below, a new CFactory is created. The parameters passed to the constructor are: the CFactory's name; a message filter that will determine which messages will make this CFactory to start a new CProcessor acting as a conversation; how many CProcessors this CFactory can manage simultaneously; and finally, a reference to the agent which owns the CFactory. Specifically, this CFactory  (called ``TALK'') will create the CProcessor when the agent receives messages with \textit{propose} performative and it can only manage one CProcessor at a time. When a CFactory is created, it has already a CProcessor template predefined by default. This template is from new instances of CProcessor will be created. This default CProcessor template has to be modified by the user in order to create its own IPs. The \emph{begin} state of the CProcessor template is defined by default. It starts creating a new IP modifying this predefined \emph{begin} state. In line 8, this \textit{begin} state is got from the template. In the lines below, a new method for this state is created. This method will be executed when the conversation reaches this \textit{begin} state. Therefore this method will be executed when the conversation starts. Every method in a conversation state has to return the name of the state the CProcessor will travel to. In this examples the begin state always travels to the state called ``PROPOSE''. In line 16, the method just defined is associated to the begin state.

Starting at line 18, a new send \textit{state} is defined called ``PROPOSE''. Once the state is created, it is necessary to define a method for this state. A method for a \textit{send} state has to return the name of the next state and also, has to assign a value to the variable \texttt{messageToSend} which is passed to the method as an argument. As can be seen, the message is going to be sent to agent Sally and the objective of the message is to propose Sally to go to the cinema.

Once the state ``PROPOSE'' has been created, registered and all the transitions to it have been added. In line 31 a new \emph{wait} state called ``WAIT'' is created.  This type of states does not need a method to execute. During its creation, it is necessary to define the name of the state and the timeout, in this case 1000ms. It is possible to define a \textit{wait} state that will wait an unlimited amount of time until a message is received if the timeout is set to 0. A transition from ``PROPOSE'' state to this \emph{wait} state is added.

After a \textit{wait} state it is mandatory to define one or more \textit{receive} states. In this example it is only defined one \textit{receive} state. A \textit{receive} state needs a method to execute and a message filter. This filter specifies which messages can be managed by this \textit{receive} state. In this example, the filter is set to null, therefore this \textit{receive} state accepts any message. The code defining the \textit{receive} state named ``RECEIVE'' starts at line 34. 

Finally it is defined the \textit{final} state of the protocol at line 46. Every protocol has to finish in a \textit{final} state. \textit{Final} states methods can use the \textit{responseMessage} variable passed as argument as a mean to return a value of the conversation. Once the method that will be executed by this state is defined, the transitions from other states to this one are added and the state registered in the CProcessor.

There is only one thing left to finish the CAgent, it is necessary to add the CFactory to the set of CFactories of the agent. It is possible to add a CFactory as an initiator one or as a pariticipant one, depending on the role the agents will play on the conversations generated by the CFactory. In this case, the CFactory is added as an initiator one. Once the CFactory has been added, it can create new CProcessors. In line 63, the agent starts a synchronous conversation, this is, the execution of the agent will halt until the conversation ends. The method \textit{startSyncConversation} is used in order to start a synchronous conversation. This method requires the name of the initiator CFactory which will create a new conversation as a parameter. The result of the conversation is stored in the variable response. In the last line of the code the result of the conversation is shown on the console.
\begin{lstlisting}[style=Java]
filter = new MessageFilter("performative = PROPOSE");
CFactory talk = new CFactory("TALK", filter, 1,this);

// A CProcessor always starts in the predefined state BEGIN.
// We have to associate this state with a method that will be
// executed at the beginning of the conversation.

BeginState BEGIN = (BeginState) talk.cProcessorTemplate().getState("BEGIN");
class BEGIN_Method implements BeginStateMethod {
   public String run(CProcessor myProcessor, ACLMessage msg) {
      // In this example there is nothing more to do than continue
      // to the next state which will send the message.
      return "PROPOSE";
   };
}
BEGIN.setMethod(new BEGIN_Method());

SendState PROPOSE = new SendState("PROPOSE");
class PROPOSE_Method implements SendStateMethod {
   public String run(CProcessor myProcessor, ACLMessage messageToSend) {
      messageToSend.setContent("Would you like to come with me to the cinema?");
      messageToSend.setReceiver(new AgentID("Sally"));
      messageToSend.setSender(myProcessor.getMyAgent().getAid());
      return "WAIT";
   }
}
PROPOSE.setMethod(new PROPOSE_Method());
talk.cProcessorTemplate().registerState(PROPOSE);
talk.cProcessorTemplate().addTransition(BEGIN, PROPOSE);

talk.cProcessorTemplate().registerState(new WaitState("WAIT", 1000));
talk.cProcessorTemplate().addTransition(PROPOSE, WAIT);

ReceiveState RECEIVE = new ReceiveState("RECEIVE");
class RECEIVE_Method implements ReceiveStateMethod {
   public String run(CProcessor myProcessor, ACLMessage messageReceived) {
      return "FINAL";
   }
}

RECEIVE.setAcceptFilter(null); // null -> accept any message
RECEIVE.setMethod(new RECEIVE_Method());
talk.cProcessorTemplate().registerState(RECEIVE);
talk.cProcessorTemplate().addTransition(WAIT, RECEIVE);

FinalState FINAL = new FinalState("FINAL");
class FINAL_Method implements FinalStateMethod {
   public void run(CProcessor myProcessor, ACLMessage responseMessage) {
      messageToSend.copyFromAsTemplate(myProcessor.getLastReceivedMessage());
      myProcessor.ShutdownAgent();
   }
}
FINAL.setMethod(new FINAL_Method());

talk.cProcessorTemplate().registerState(FINAL);
talk.cProcessorTemplate().addTransition(RECEIVE, FINAL);
talk.cProcessorTemplate().addTransition(PROPOSE, FINAL);

// The template processor is ready. We add the factory, in this case as a participant one
this.addFactoryAsInitiator(talk);

// Finally Harry starts the conversation.
ACLMessage response = this.startSyncConversation("TALK");

System.out.println(this.getAid().name + " : Sally tell me "
+ response.getPerformative() + " " + response.getContent());
\end{lstlisting}

\subsection{Using a CFactory Template}
\label{subsec:usingATemplate}
Defining a CFactory and its CProcessor template can be a laborious task. In order to facilitate this, a set of CFactories templates are provided in Magentix2. At the moment the templates are:
\begin{itemize}
 \item FIPA Request
 \item FIPA Contract-net
 \item FIPA Recruiting
\end{itemize}
All of this templates are available in both versions, initiator and participant.

The source code of the examples shown in this sections are accessible at the folder examples/src/requestFactory.

A CFactory template is a java class that has already defined the states and the transitions of the CProcessor template. A template can be modified in order to adapt it to any specification. Some templates have abstract methods that are necessary to implement by the users. Others methods offer a default behaviour that can be modified if needed. As an example, it is shown how to adapt the FIPA Request Initiator template provided in Magentix2 to a scenario where one agent (Harry) asks another agent (Sally) for her phone number.

In this case it is necessary to create a new class that extends the template FIPA\_REQUEST\_Ini\-tia\-tor (lines 6-12). This class has an abstract method that is mandatory to implement, the \texttt{doInform} method (lines 7-11). This method is executed when the initiator receives the results of what it requested. All the other methods for the other states have a default behaviour that can be modified, in this example it is not necessary to do so.

The message that contains the request is created (lines 17-21). Afterwards a CFactory from the template is created (line 29). During the creation, it is required to specify the name of the new CFactory, the request message, the agent owner of the CFactory and the time in milliseconds that the agent will wait for the inform or failure message. Once the CFactory template is defined, it is possible to create a new instance from it. 

Finally, the just created CFactory is added to the agent (line 30), and in the last line of the code, a synchronous conversation from this CFactory is started.

\begin{lstlisting}[style=Java]
// In this example the agent is going to act as the initiator in the
// REQUEST protocol defined by FIPA.
// In order to do so, she has to extend the class FIPA_REQUEST_Initiator
// implementing the method that receives results of the request (doInform)

class myFIPA_REQUEST extends FIPA_REQUEST_Initiator {
   protected void doInform(CProcessor myProcessor, ACLMessage msg) {
      System.out.println(myProcessor.getMyAgent().getName() + ": "
      + msg.getSender().name + " informs me "
      + msg.getContent());
   }
}

// We create the message that will be sent in the doRequest method
// of the conversation

msg = new ACLMessage(ACLMessage.REQUEST);
msg.setReceiver(new AgentID("Sally"));
msg.setContent("May you give me your phone number?");
msg.setProtocol("fipa-request");
msg.setSender(getAid());

// The agent creates the CFactory that creates processors that initiate
// REQUEST protocol conversations. In this
// example the CFactory gets the name "TALK", we don't add any
// additional message acceptance criterion other than the required
// by the REQUEST protocol 

CFactory talk = new myFIPA_REQUEST().newFactory("TALK", msg,1, this, 5000);
this.addFactoryAsInitiator(talk);

// finally the new conversation starts. Because it is synchronous, 
// the current interaction halts until the new conversation ends.
this.startSyncConversation("TALK");
\end{lstlisting}


CFactory templates are useful for reusing code. It is possible to create templates of other IP or modify the existing ones in order to adapt them.

\subsection{Creating a CFactory Template}
This section explains how to implement a new CFactory template. In the following example we are going to implement a template for the CFactory shown in section \ref{subsec:cprocessor}.

First the states are defined, it is in this moment when it is possible to define default methods and choose which methods are abstract and therefore, mandatory to implement for the user. The definition of the states is shown below.
\begin{lstlisting}[style=Java]
public abstract class MyTemplate {
   //We can define a set of static values for referencig sates
   public static String BEGIN = "BEGIN";
   public static String PROPOSE = "PROPOSE";
   public static String WAIT = "WAIT";
   public static String RECEIVE = "RECEIVE";
   public static String RECEIVE = "FINAL";
   
   protected void doBegin(CProcessor myProcessor, ACLMessage msg) {
      System.out.println("This is the begin state");
   }

   class BEGIN_Method implements BeginStateMethod {
      public String run(CProcessor myProcessor, ACLMessage msg) {
	 doBegin(myProcessor, msg);
	 return PROPOSE;
      };
   }
   
   // We want the user to implement his/her method here
   protected abstract void doPropose(CProcessor myProcessor, ACLMessage messageToSend);

   class PROPOSE_Method implements SendStateMethod {
      public String run(CProcessor myProcessor, ACLMessage messageToSend) {
	 doPropose(myProcessor, messageToSend);
	 // This IP is so simple and hasn't any choices. If it had
	 // then we can set the return type of the doRequest method
	 // to String and use it as a return value for this method
	 return WAIT;
      }
   }
   // We want the user to implement his/her method here
   protected abstract void doReceive(CProcessor myProcessor, ACLMessage msg);

   class RECEIVE_Method implements ReceiveStateMethod {
      public String run(CProcessor myProcessor, ACLMessage messageReceived) {
	 doReceive(myProcessor, messageReceived);
	 return FINAL;
      }
   }
   
   protected void doFinal(CProcessor myProcessor, ACLMessage messageToSend) {
      messageToSend = myProcessor.getLastSentMessage();
   }

   class FINAL_Method implements FinalStateMethod {
      public void run(CProcessor myProcessor, ACLMessage messageToSend) {
	 doFinal(myProcessor, messageToSend);
      }
   }
\end{lstlisting}

Once all the states are defined, the next step is to create a method that returns a new CFactory. In this method, new states are created and the methods defined before are assigned to them. The transitions between the states are also defined in this method. Depending on the IP,  some parameters will be needed. In this case, it is only necessary to specify the name of the CFactory, the maximum number of simultaneous conversations, the agent who owns the CFactory and the timeout for the wait state. The code of this method is shown below.
\begin{lstlisting}[style=Java]
   public CFactory newFactory(String name, int availableConversations, CAgent myAgent, long timeout) {
      CFactory theFactory = new CFactory(name, null,availableConversations, myAgent);
      // Processor template setup
      CProcessor processor = theFactory.cProcessorTemplate();

      // BEGIN State
      BeginState BEGIN = (BeginState) processor.getState("BEGIN");
      BEGIN.setMethod(new BEGIN_Method());

      // PROPOSE State
      SendState PROPOSE = new SendState("PROPOSE");

      PROPOSE.setMethod(new PROPOSE_Method());
      processor.registerState(PROPOSE);
      processor.addTransition(BEGIN, PROPOSE);
      
      // WAIT State
      WaitState WAIT = new WaitState("WAIT", timeout);
      processor.registerState(WAIT);
      processor.addTransition(PROPOSE, WAIT);
      
      // RECEIVE State

      ReceiveState RECEIVE = new ReceiveState("RECEIVE");
      RECEIVE.setMethod(new RECEIVE_Method());
      filter = new MessageFilter(""); //accept any message
      RECEIVE.setAcceptFilter(filter);
      processor.registerState(RECEIVE);
      processor.addTransition(WAITE, RECEIVE);
      
      FinalState FINAL = new FinalState("FINAL");
      FINAL.setMethod(new FINAL_Method());
      processor.registerState(FINAL);
      processor.addTransition(RECEIVE, FINAL);
      
      return theFactory;
   }
};
\end{lstlisting}
How to use a CFactory template is shown in the previous section \ref{subsec:usingATemplate}. For this specific template the instructions are the same.
%==================================================================
%================== SEXTA SECCIÓN =================================
%==================================================================
\section{BDI Agents: JasonAgents}
Jason\cite{bordini05} is an interpreter for an extended version of AgentSpeak(L)\cite{Rao96} and implements the operational semantics of that language. It has been developed by Jomi F. H\"ubner and Rafael H. Bordini. Jason has been integrated in Magentix2 platform, therefore we can program agents in AgentSpeak and run them on Magentix2 platform. For examples and demos of how to program in AgentSpeak(L), please refer to the webpage of the Jason project: \url{http://jason.sourceforge.net/Jason/Jason.html}.

Magentix2 integrates Jason providing two classes: JasonAgent and MagentixAgArch. MagentixAgArch manages the AgentSpeak(L) interpreter, the reasoning cycle of the agent, and how the agent acts and perceives to/from the environment. The JasonAgent class acts as a link between the AgentSpeak(L) interpreter and the platform. Both classes can be modified and adapted to the desired needs, but usually, only MagentixAgArch would need to be modified in order to add external actions to the agent (external actions are actions which affect the agent environment).

The code of how to create and execute a basic JasonAgent is shown below.
\begin{lstlisting}[style=Java]
MagentixAgArch arch = new MagentixAgArch();
JasonAgent agent = new JasonAgent(new AgentID("bob"), "./src/test/java/jasonTest_1/demo.asl", arch);
agent.start();
\end{lstlisting}
In the code shown above, first an instance of MagentixAgArch class called ``arch'' is created, then a JasonAgent called ``agent'' is created, in order to create a JasonAgent it is necessary to specify its AgentID, the file with the AgentSpeak(L) program that the interpreter will execute and the agent architecture the agent will use, in this case, a standard MagentixAgArch. Finally, start the execution of the agent starts.

It is possible to modify the agent architecture, in the following example the MagentixAgArch default architecture will not be used, instead a new one is created, which extends from MagentixAgArch.
\begin{lstlisting}[style=Java]
public class SimpleArchitecture extends MagentixAgArch {

// this method just adds some perception to the agent
@Override
   public List<Literal> perceive() {
      List<Literal> l = new ArrayList<Literal>();
      l.add(Literal.parseLiteral("x(10)"));
      return l;
   }
}
\end{lstlisting}
This new architecture, called SimpleArchitecture, just adds a perception to the agent overriding the method \texttt{perceive} of the MagentixAgArch class. As said before, usually the architecture is modified in order to add new actions to the agent, this could be done just overriding the method \texttt{act(ActionExec action, List<ActionExec> feedback)} of the architecture. This method receives an action as an argument and a list of action executions called feedback. In the code below, it is shown how to manage a new external action of the agent called ``doAction''.
\begin{lstlisting}[style=Java]
@Override
public void act(ActionExec action, List<ActionExec> feedback)
{
getTS().getLogger().info("Agent " + getAgName() +" is doing: " + action.getActionTerm());
   if(action.getActionTerm().equals("doAction")){
      //perform the action
      //set the result, for example always true
      action.setResult(true);
      //add the executed action to the list of action executions
      feedback.add(action);
   }
}
\end{lstlisting}

The code in AgentSpeak(L) is written in a different file, the path to the file is passed as an argument to the constructor of the JasonAgent class. A sample code of an AgentSpeak(L) program is shown below.
\begin{lstlisting}
vl(1).
vl(2).

+vl(X)[source(Ag)] 
   :  Ag \== self
   <- .print("Received tell ",vl(X)," from ", Ag).
   
+!goto(X,Y)[source(Ag)] : true
   <- .println("Received achieve ",goto(X,Y)," from ", Ag).

+?t2(X) : vl(Y) <- X = 10 + Y.

+!kqml_received(Sender, askOne, fullname, ReplyWith) : true
   <- .send(Sender,tell,"Maria dos Santos", ReplyWith). // send the answer
\end{lstlisting}



%==================================================================
%================== ARGUMENTATIVE AGENTS===========================
%==================================================================
%%% Se crea como un fichero aparte y luego se copiarï¿½ el contenido en la secciï¿½n programming agents antes de luanching with security

\section{Argumentative Agents}
\label{sec:introductionArgAgents}
This section describes the \emph{argumentative agents} API of Magentix2. This API allows agents to engage in argumentation dialogues to reach agreements about the best solution for a problem that must be solved.

First, we introduce the theory of the argumentation framework that Magentix2 argumentative agents implement. Then, the implementation details of the API are shown. Finally, a guide to run argumentative agents and an example of a call centre application are provided.

\subsection{Argumentation Framework}

Argumentative agents implement a case-based argumentation framework to generate arguments, to select the best argument to put forward taking into account their social context and to evaluate arguments in view of other arguments proposed in the dialogue. Also, they can use different dialogue strategies to exchange information and engage in the argumentation process. In this section we briefly introduce the framework and the dialogue strategies that Magentix2 argumentative agents use. For a more detailed explanation we refer the reader to \cite{Heras11}.

\subsubsection{Framework Architecture}
\label{subsubsec:framework}
Magentix2 argumentative agents can use a computational case-based argumentation framework to manage argumentation processes. This section outlines the main components of this framework. 

% Thus, the framework consists of: 
% 
% \begin{itemize}
% 	\item A definition for the notion of arguments that agents use to justify their proposals.
% 	\item The logical language that agents use to represent knowledge and engage in argumentation processes.
% 	\item A definition for the concept of conflict between arguments, which specifies when an argument attacks other different argument.
% 	\item A definition for the concept of defeat between arguments, which specifies which attacks over arguments succeed.
% 	\item A definition for the possible acceptability status of an argument during the dialogue, which classifies it as \emph{acceptable} (not defeated by other argument), \emph{unacceptable} (defeated) or \emph{undecided} (there is not enough information to decide its acceptability status) in view of its relations with other arguments \cite{Dung95}.
% \end{itemize}

%\textit{Knowledge Resources}

We have three types of knowledge resources that the agents can use to generate, select and evaluate arguments by using our framework. These resources are implemented in Magentix2 as java clases (see \ref{subsec:implementation}):

\begin{description}
 \item[A database of argumentation schemes] with a set of schemes with the structure proposed in \cite{Walton08}, which represent stereotyped patterns of common reasoning in the application domain where the framework is implemented. An argumentation scheme consists of a set of premises and a conclusion that is presumed to follow from them. Also, each argumentation scheme has associated a set of \emph{critical questions} that represent potential attacks to the conclusion supported by the scheme.
 \item[A case-base with domain-cases] that represent previous problems and their solutions. Agents can use this knowledge resource to generate their positions in a dialogue and arguments to support them. The \emph{position} of an agent represents the \emph{solution} that this agent proposes. Also, the acquisition of new domain-cases increases the knowledge of agents about the domain under discussion. 
 \item[A case-base with argument-cases] that store previous argumentation experiences and their final outcome. Argument-cases have three main objectives: they can be used by agents 1) to generate new arguments; 2) to select the best position to put forward in view of past argumentation experiences; and 3) to store the new argumentation knowledge gained in each agreement process, improving the agents' argumentation skills.
\end{description}

\textit{Argumentation Schemes}

The concrete set of argumentation schemes used also depends on the application domain of our argumentation framework. The Magentix2 argumentation API only provides a basic template for them with the common components of Walton's-like argumentation schemes \cite{Walton08}. A user that wants to use this knowledge resource must overwrite the \lstinline{ArgumentationScheme.java} class of the Magentix2 \lstinline{argAgents.knowledgeResources} package.

\textit{Domain-Cases}

The structure of domain-cases that an argumentation system that implements our framework depends on the application domain. As example, Figure \ref{fig:domCase} shows the structure of a possible domain-case. Here, an argumentative agent must solve a problem characterised by three premises of different data types (P1, P2 and P3). In this example, the argumentative agent \emph{ArgAgent} has found the domain-case \emph{DC1} that matches de description of the problem to solve (has all or some of the premises of the problem with the same data values for this premises), also including an extra feature (P4). Note that here we assume that domain-cases also store the value promoted by the solution that they represent (see on the arguments structure below for a more detailed explanation). This is a design decision that can be replaced by any other assumption. Domain-cases are implemented in Magentix2 by using the \lstinline{DomainCase.java} class of the \lstinline{argAgents.knowledgeResources} package.

\begin{figure}[t!]
  \begin{center}
    \includegraphics[width=0.8\textwidth]{ProgrammingAgents/images/domainCase}
 \end{center}
  \caption{Example Structure of a Domain-Case}
\label{fig:domCase}
\end{figure}

\textit{Arguments}

Arguments in Magentix2 are implemented as java classes, concretely, in the \lstinline{Argument.java} class of the Magentix2 \lstinline{argAgents.knowledgeResources} package. In our proposal, arguments that agents interchange have the following  structure:
% \begin{definition}[Argument]
% \label{def:argument}
%  $Arg = \{\phi, v, <S>\}$, where $\phi$ is the conclusion of the argument, $v$ is the value that the agent wants to promote and $<S>$ is a set of elements that justify the argument (the support set).
%\end{definition}

\begin{lstlisting}
public Argument(long id, Conclusion conclusion, 
	int timesUsedConclusion, String promotedValue, 
	SupportSet supportSet, 
	DependencyRelation proponentDepenRelation)
\end{lstlisting}
where \texttt{conclusion} is the conclusion of the argument, \texttt{timesUsedConclusion} stores the number of times that this conclusion has been used, \texttt{promotedValue} is the value that the agent wants to promote with this argument, \texttt{supportSet} is a set of elements that justify the argument and \texttt{proponentDepenRelation} is the dependency relation (power, authorisation or charity) established between the proponent of the argument and the opponent that the argument is addressed. Thus, in our case-based argumentation framework arguments promote values. These values can be personal goods (e.g. efficiency, accuracy, etc.) or also social goods inherited from the agents' dependency relations. Preferences over values can determine the reasons that lead an agent to propose a specific argument or to accept or refuse an argument from another agent. 

The support set is a knowledge resource of the Magentix2 \lstinline{argAgents.knowledgeResources} package, represented by the \lstinline{SupportSet.java} class, and can consist of different elements, depending on the argument purpose. On one hand, if the argument justifies a potential solution for a problem, the support set is the set of features (\emph{premises}) that represent the context of the domain where the argument has been put forward (those premises that match the problem to solve and other extra premises that do not appear in the description of this problem but that have been also considered to draw the conclusion of the argument) and optionally, any knowledge resource used by the proponent to generate the argument (\emph{domain-cases}, \emph{argument-cases} and \emph{argumentation schemes}). This type of argument is called a \emph{support argument}. On the other hand, if the argument attacks the argument of an opponent, the support set can also include any of the allowed attack elements of our framework. These are: \emph{distinguishing premises}, \emph{counter-examples} or \emph{critical questions}. This other type of argument is called an \emph{attack argument}. 

\begin{definition}[Distinguishing Premise]
 A distinguishing premise is a premise that does not appear in the description of the problem to solve and has different values for two cases or a premise that appears in the problem description and does not appear in one of the cases. %For instance, the premise \emph{"P4"} would be a distinguishing premise between the domain-case shown in Figure \ref{fig:domCase} and another domain-case, say \emph{DC2}, that has exactly the same problem description than \emph{DC1}, but that stores different data for this premise.
\end{definition}

\begin{definition}[Counter-Example]
 A counter-example for a case is a previous case (i.e. a domain-case or an argument-case that was deemed acceptable), where the problem description of the counter-example matches the current problem to solve and also subsumes the problem description of the case, but proposing a different solution. %To illustrate this concept, let us assume that the domain-case \emph{DC2}, which has the same problem description than \emph{DC1}, proposes an alternative solution. Therefore, \emph{DC2} could be used to generate a counter-example attack to \emph{DC1} and vice-versa. 
\end{definition}

\begin{definition}[Critical Question]
 A \emph{critical question} is a question associated to an argumentation scheme that represents a potential way in which the conclusion drawn from the scheme can be attacked. Therefore, if the opponent asks a critical question, the argument that supports this argumentation scheme remains temporally rebutted until the question is conveniently answered. %This characteristic of argumentation schemes makes them very suitable to devise ways of attack the conclusions drawn from other agents.	
\end{definition}

\textit{Argument-Cases}

Argument-cases are the main structure that we use to computationally represent argumentation knowledge in Magentix2, concretely in the \lstinline{ArgumentCase.java} class of the Magentix2 \lstinline{argAgents.knowledgeResources} package. Their structure is generic and domain-independent. Figure \ref{fig:argCase} shows the generic structure of an argument-case.

\begin{figure}[t]
  \begin{center}
    \includegraphics[width=0.8\textwidth]{ProgrammingAgents/images/argumentCase.pdf}
 \end{center}
  \caption{Structure of an Argument-Case}
\label{fig:argCase}
\end{figure}

Argument-cases have the three possible types of components that usual cases of CBR systems have: the description of the state of the world when the case was stored (\emph{Problem}); the solution of the case (\emph{Conclusion}); and the explanation of the process that gave rise to this conclusion (\emph{Justification}).

The problem description has a \emph{domain context} that consists of the \emph{premises} that characterise the argument. In addition, if we want to store an argument and use it to generate a persuasive argument in the future, the features that characterise its \emph{social context} must also be kept. The social context of the argument-case includes information about the \emph{proponent} and the \emph{opponent} of the argument and about their \emph{group}. Moreover, we also store the preferences (\emph{ValPref}) of each agent or group over the set of possible \emph{values} that arguments can promote (pre-defined in the system). Finally, the \emph{dependency relation} between the proponent's and the opponent's roles is also stored. In our framework, we consider three types of dependency relations: \emph{power}, when an agent has to accept a request from another agent because of some pre-defined domination relationship between them; \emph{authorisation}, when an agent has signed a contract with another agent to provide it with a service and hence, the contractor agent is able to impose its authority over the contracted agent and \emph{charity}, when an agent is willing to answer a request from another agent without being obliged to do so.

In the solution part, the \emph{conclusion} of the case, the \emph{value} promoted, and the \emph{acceptability status} of the argument at the end of the dialogue are stored. The acceptability status shows if the argument was deemed \emph{acceptable}, \emph{unacceptable} or \emph{undecided} in view of the other arguments that were put forward in the agreement process. Therefore, an argument is deemed acceptable if it remains undefeated at the end of the argumentation dialogue, unacceptable if it was defeated during the dialogue and undecided if its acceptability status cannot be determined with the current information about the dialogue. %In our framework, the acceptance of an argument is determined by the defeat relation defined in \cite[Chapter 3]{Heras11}, which determines which argument prevails when an argument attacks other argument, taking into account the agents that have proposed these arguments, their preferences over values and their dependency relation. 
In addition, the conclusion part includes information about the possible \emph{attacks} that the argument received during the process. These attacks could represent the justification for an argument to be deemed unacceptable or else reinforce the persuasive power of an argument that, despite being attacked, was finally accepted. 

Finally, the justification part of an argument-case stores the information about the knowledge resources that were used to generate the argument represented by the argument-case (the set of domain-cases and argument-cases). In addition, the justification of each argument-case has a \emph{dialogue-graph} (or several) associated, which represents the sequence of arguments that form the dialogue where the argument was proposed. In this way, the complete conversation is stored as a directed graph that links argument-cases that represent the arguments of the dialogue. This graph can be used later to improve the efficiency in an argumentation dialogue in view of a similar dialogue that was held in the past.

\subsubsection{Dialogue Strategies}
\label{subsubsec:strategies}

In each step of an argumentation process, a Magentix2 argumentative agent can choose a specific locution to put forward and a content for it. The mechanism that agents follow to make such decisions is known as \emph{dialogue strategy}. 
%The specific locutions and dialogue rules that agents use can be found in \cite[Chapter 4]{Heras11} and will be briefly explained in Section \ref{subsec:argCBRAgents}. Also, the concrete reasoning process and algorithms that agents follow to generate, select and evaluate arguments from their knowledge resources are explained in \cite[Chapter 3]{Heras11}. Here, we focus on the case-based dialogue strategies that agents can follow during the argumentation process, which define the best locution to. 
In our case-based argumentation framework, agents select the best locution to bring up depending on the \emph{dialogue protocol} that they are following and the content of this locution depending on the knowledge that they have in their knowledge resources and the \emph{tactic} that they follow to argue. 
%The profile of an agent defines its attitude towards the arguments put forward by itself and other different agents during the dialogue. Concretely, the Magentix2 argumentative agent implements an \emph{argumentative profile}.

A Magentix2 argumentative agent will not initially accept any position from a peer. This agent will challenge positions of other peers when they are different from its position, even if they appear in its list of potential positions to propose. Also, it will try to generate an answer for any attack that it receives, but opposite to open-minded agents, argumentative agents do not accept the position of the peer that generated the attack if the last wins the debate. If an argumentative agent cannot generate positions, it will not participate in the dialogue. Finally, agents will accept arguments from other agents that have a power or authorisation dependency relation over them. %Recall that in any case the acceptance of an argument is subjected to the defeat relation defined in the argumentation framework proposed in \cite[Chapter 3]{Heras11}. 

Depending on its dialogue protocol, the agent will choose the next locution to put forward on the dialogue game. Then, among the potential arguments that the agent may generate, it has to select one to propose. This implies to select the content of the locution to assert the argument. To make this selection, Magentix2 argumentative agents can use different tactics. From our point of view, a tactic consist on assigning more or less weight to the elements of an argument \emph{support factor} used to select positions and arguments. The support factor estimates how suitable a current position or argument is in view of the suitability of similar arguments (to support or attack similar positions or arguments) put forward in previous argumentation dialogues, which are stored in the agent's case-base of argument-cases. In this way, the agent can select the most suitable position or argument to propose next. The support factor is computed by a linear combination of several parameters:
%, which are calculated by using the following formulas. In them, $argC$ is the subset of argument-cases from the whole set $arg$ stored in the agent case-base with the same problem description and conclusion as the current argument; $argAccC$ are those in $argC$ that were deemed acceptable at the end of the dialogue; $argAccCAtt$ are those in $argAccC$ that were attacked; $minAtt$ and $maxAtt$ are the minimum and maximum number of attacks received by any argument-case in $argAccCAtt$; $minS$ and $maxS$ are the minimum and maximum number of steps from any argument-case in $argC$ to the last node of its dialogue graph and; $minKr$ and $maxKr$ are the minimum and maximum number of knowledge resources used to generate any argument-case in $argC$. Also, we assume that the modifier \# represents the number of elements of a set. 

\begin{itemize}
 \item\textbf{Persuasiveness Degree ($PD$):} is a value that represents the expected persuasive power of an argument by checking how persuasive an argument-case with the same problem description and conclusion was in the past. %To compute this degree, the number $\#argAccC$ of argument-cases that were deemed acceptable out of the total number of retrieved argument-cases $\#argC$ with the same problem description and conclusion as the current argument is calculated:
%  \begin{equation}
%  \label{eq:pd}
%  PD=\left\{
%  \begin{array}{ll}
%  0, & if~\#argC = \emptyset\\
%  \dfrac{\#argAccC}{\#argC},& otherwise \end{array}\right.
%  \end{equation}
%  with $\#argAccC$, $\#argC \in \mathbb{N}$ and $PD \in [0, 1]$, from less to more persuasive power. 
% \vspace{0.5cm}

 \item\textbf{Support Degree ($SD$):} is a value that provides an estimation of the probability that the conclusion of the current argument was acceptable at the end of the dialogue. %It is based on the number of argument-cases $\#argAccC$ with the same problem description and conclusion that where deemed acceptable out of the total number of argument-cases $arg$ retrieved.
%  \begin{equation}
%  \label{eq:sd}
%  SD=\left\{
%  \begin{array}{ll}
%  0, & if~\#arg = \emptyset\\
%  \dfrac{\#argAccC}{\#arg},& otherwise \end{array}\right.
%  \end{equation}
%  with $\#argAccC, \#arg \in \mathbb{N}$ and $SD \in [0, 1]$ from less to more support degree.
% \vspace{0.5cm}

 \item\textbf{Risk Degree ($RD$):} is a value that estimates the risk for an argument to be attacked in view of the attacks received for an argument(s) with the same problem description and conclusion in the past. %It is based on the number of argument-cases $\#argAccCAtt$ that were attacked out of the total number of $\#argAccC$ argument-cases with the same problem description and conclusion retrieved that were deemed acceptable.
%  \begin{equation}
%  \label{eq:rd}
%  RD=\left\{
%  \begin{array}{ll}
%  0, & if~\#argAccC = \emptyset\\
%  \dfrac{\#argAccCAtt}{\#argAccC}, & otherwise \end{array}\right.
%  \end{equation}
%  with $\#argAccCAtt$, $\#argAccC \in \mathbb{N}$ and $RD \in [0, 1]$, from less to more risk of attack.
% \vspace{0.5cm}

 \item\textbf{Attack degree ($AD$):} is a value that provides an estimation of the number of attacks received by a similar argument(s) in the past. %To compute this degree, the set of argument-cases with the same problem description that were deemed acceptable is retrieved. Then, this set is separated into several subsets, one for each different conclusion that these argument-cases entail. The sets whose conclusion match with the conclusions of the arguments to assess are considered, while the other sets are discarded. Thus, we have a set of argument-cases for each different potential argument (and its associated conclusion) that we want to evaluate. For each argument-case in each set, the number of attacks received is computed (the number of distinguishing premises and counter-examples received). Then, for each set of argument-cases, the average number of attacks received is computed. The attack degree of each argument is calculated by a linear transformation:
%  \begin{equation}
%  \label{eq:ad}
%  AD=\left\{
%  \begin{array}{ll}
%  0, & if~maxAtt = minAtt\\
%  \dfrac{att - minAtt}{maxAtt - minAtt}, & otherwise \end{array}\right.
%  \end{equation}
%  with $minAtt$, $maxAtt$, $att$ $\in \mathbb{N}$ and $AD \in [0, 1]$ from less to more degree of attack.
% \vspace{0.5cm}

 \item\textbf{Efficiency degree ($ED$):} is a value that provides an estimation of the number of steps that it took to reach an agreement posing a similar argument in the past. %It is based on the depth $n$ from the node representing a similar argument-case retrieved to the node representing the conclusion in the dialogue graphs associated with it. To compute this degree, the same process to create the subsets of argument-cases as in the above degree is performed. Then, for each argument-case in each subset, the number of dialogue steps from the node that represents this argument-case to the end of the dialogue is computed. Also, the average number of steps per subset is calculated. Finally, the efficiency degree of each argument is calculated by a linear transformation:
%  \begin{equation}
%  \label{eq:ed}
%  ED=\left\{
%  \begin{array}{ll}
%  0, & if~maxS = minS\\
%  1 - \dfrac{n - minS}{maxS - minS}, & otherwise \end{array}\right.
%  \end{equation}
%  with $minS$, $maxS$, $n \in \mathbb{N}$ and $ED \in [0, 1]$ from less to more efficiency.
% \vspace{0.5cm}

 \item\textbf{Explanatory Power ($EP$):} is a value that represents the number of pieces of information that each argument covers. It is based on the number of knowledge resources were used to generate each similar argument-case retrieved. %To compute this number, the same process to create the subsets of argument-cases as in the above degrees is performed. Then, for each argument-case in each set, the number of knowledge resources in the justification part is computed (the number of domain-cases and argument-cases). Then, for each set of argument-cases, the average number of knowledge resources used is computed. The explanatory power of each argument is calculated by a linear transformation:
%  \begin{equation}
%  \label{eq:ep}
%  EP=\left\{
%  \begin{array}{ll}
%  0, & if~maxKr = minKr\\
%  \dfrac{kr - minKr}{maxKr - minKr}, & otherwise \end{array}\right.
%  \end{equation}
%  with $minKr$, $maxKr$, $kr \in \mathbb{N}$ and $EP \in [0, 1]$ from less to more explanatory power.
\end{itemize}

The selection of these specific parameters to estimate the support factor of a position or argument has been determined by the nature of the elements of our argument-cases. Thus, the persuasiveness and support degrees take into account the acceptability status stored in the argument-cases, the attack and risk degrees look at the attacks received by the argument that an argument-case represents, the efficiency degree makes use of the dialogue graphs stored in the argument-cases and the explanatory power computes the number of justification elements that argument-cases have. Therefore, the support factor is computed by using the following formula:

\begin{equation}
 \begin{aligned}
 SF = & w_{PD} * PD + w_{SD} * SD + w_{RD} * (1-RD)\\
 & + w_{AD} * (1-AD) + w_{ED} * ED + w_{EP} * EP
 \end{aligned}
 \label{eq:sf}
\end{equation}
where $w_i \in [0, 1], \sum w_i = 1$ are weight values that allow the agent to give more or less importance to each parameter of the support factor. In Magentix2 argumentative agents, these weights can be set by specifying the corresponding parameters in the agent's constructor, as will be show in Section \ref{subsec:howTo}.

Thus, an agent can use the following dialogue tactics depending on the weight that it assigns to the elements of the support factor when it selects the best argument to bring up in each step of the argumentation dialogue:

\begin{itemize}
 \item Persuasive Tactic: the agent selects such arguments which similar argument-cases were more persuasive in the past (assigns more weight to the persuasiveness degree).
 \item Maximise-Support Tactic: the agent selects such arguments that have higher probability of being accepted at the end of the dialogue (assigns more weight to the support degree).
 \item Minimise-Risk Strategy: the agent selects such arguments that have a lower probability of being attacked (assigns more weight to the risk degree).
 \item Minimise-Attack Tactic: the agent selects such arguments that have received a lower number of attacks in the past (assigns more weight to the attack degree).
 \item Maximise-Efficiency Tactic: the agent selects such arguments that lead to shorter argumentation dialogues (assigns more weight to the efficiency degree).
 \item Explanatory Tactic: the agent selects such arguments that cover a bigger number of cases or argumentation schemes. That is, such arguments that are similar to argument-cases that have more justification elements (assigns more weight to the explanatory power).
\end{itemize}

As pointed out before, the dialogue strategy that an agent follows determines the locution and content that it puts forward in each step of the dialogue. Thus, different strategies can be more or less suitable depending on the other agents that participate in the dialogue, the tactics that they follow and their available knowledge resources. 

\subsection{Argumentation API}
\label{subsec:implementation}
In this section, we define the different modules that implement the argumentation API of the Magentix2 platform and their functionality. For a tutorial on how to use these modules for programming argumentative agents see Section \ref{subsec:howTo}.

\begin{itemize}
 \item \textbf{Domain CBR module}: consists of a CBR module with domain-dependent data (previous problem-solving experiences stored in the form of domain-cases). This CBR has to be initialised with data of the application domain. 
 
 \item \textbf{Argumentation CBR module}: consists of a CBR module with argumentation data (previous arguments stored in the form of argument-cases). Once an agent has a list of potential solutions for a current problem, it has to select the best position to put forward among them. Also, the agent can generate arguments to support its position and attack another agent's arguments and positions. Then, this module is used to look for previous argumentation experiences and use this knowledge to select the best positions and arguments to propose. 

 \item \textbf{Argumentative agent}: is an agent with a Domain CBR and an Argumentation CBR able to engage in an argumentation dialogue to solve a problem. This agent learns about the domain problem and the argumentation dialogue adding and updating cases into the domain and argumentation case-bases in each CBR run. %Moreover, the agent can play any role defined in the system. 
 
 \item \textbf{Commitment Store}: is a resource of the argumentation framework that stores all the information about the agents participating in the problem solving process, argumentation dialogues between them, positions and arguments. By making queries to this resource, every agent of the framework can read the information of the dialogues that it is involved in. To facilitate the communication among argumentative agents and the commitment store, this resource has been implemented as a Magentix2 \texttt{CAgent}.

\end{itemize}

\subsubsection{Argumentative Agents: ArgCAgent Class}
\label{subsubsec:argCAgents}

With the class \lstinline{ArgCAgent.java} Magentix2 distribution includes an implementation of an argumentative agent. This agent is an extension of the Magentix2 conversational agent (\texttt{CAgent}, see Section \ref{sec:CAgents}). Argumentative agents have two CBR modules: Domain CBR and Argumentation CBR. %These modules are shown in the Figure \ref{fig:infrastructure}. Argumentative agents have different parameters to configure in their constructor, as will be explained in Section \ref{subsec:howTo}. 
% \begin{figure}[h]
%   \centering
%     \includegraphics[width=.9\linewidth]{ProgrammingAgents/images/frameworkDiagram}
%   \caption{Infrastructure}
% \label{fig:infrastructure}
% \end{figure}
The main functionalities of the argumentative agents are the generation, selection and evaluation of positions and arguments. These are specified as methods, to facilitate a better understanding of the code and to facilitate modifications and updates. Table \ref{tab:ArgCAgentMethods} provides an overview of the main methods used to manage positions and arguments in the \lstinline{ArgCAgent.java} class. Next, we explain how argumentative agents can manage positions and arguments.

\begin{table}[h!t]
\begin{tabulary}{1\linewidth}{|l|L|}
\hline
\textbf{Method} & \textbf{Description} \\ 
\hline
addPosition & Returns an \texttt{ACLMessage} with the locution ADDPOSITION and a \texttt{Position} to send to the Commitment Store\\
\hline
createMessage & Creates and returns an \texttt{ACLMessage} with the message arguments. Messages are managed by the main \texttt{execution} method of \texttt{cAgents} and are sent and received in the corresponding \textit{send} and \textit{receive} states (see Section \ref{sec:CAgents})\\
\hline
generateAttackArgument & Returns an attack \texttt{Argument} against the given argument of the given agent identifier\\
\hline
generateCEAttack & Returns a counter-example attack \texttt{Argument} against the agent of the given agent identifier, and its given premises\\
\hline
generateDPAttack & Returns a distinguishing premises attack \texttt{Argument} against the agent of the given agent identifier, and its given premises\\
\hline
 generatePositions & Returns an \texttt{ArrayList} of \texttt{Position} with all generated positions to solve the specified problem, ordered from more to less suitability degree to the problem\\
\hline
generateSupportArguments & Returns an \texttt{ArrayList} of support \texttt{Argument} for the given \texttt{Position} against the given agent identifier\\
\hline
getDifferentPositions & Returns an \texttt{ArrayList} of positions that are different from the defended position and also are not asked yet\\
\hline
getDistinguishingPremises & Returns an \texttt{ArrayList} with distinguishing premises between the HashMaps given as arguments\\
\hline
getUsefulPremises & Returns a \texttt{HashMap} of the useful premises of the agent of the current problem to solve (the premises of the \texttt{Position} that are specified in the problem characterisation).\\
\hline
updateCBs & Adds the final solution to the current problem and adds it in the domain-cases case-base. Also, stores all the generated argumentation data in the argument-cases case-base. Finally, makes a cache of the domain CBR and the argumentation CBR\\
\hline
\end{tabulary}
\caption{\lstinline{ArgCAgent.java} methods to manage positions and arguments}
\label{tab:ArgCAgentMethods}
\end{table}

\underline{POSITION MANAGEMENT}

A position is a solution that defends an agent as the correct one to apply to solve the problem at hand. The position generation is made in two steps. First, the agent retrieves from its Domain CBR the most similar domain-cases to the current problem to solve (by using the \texttt{retrieve} method of the \lstinline{DomainCBR.java}) class. With them, the agent is able to propose its position in view of the solutions applied to similar problems in the past. Then, the agent evaluates the suitability of each position by using its Argumentation CBR to compute the support factor parameters (by using the method \texttt{getDegrees} of the \lstinline{ArgCBR.java} class). Then, each position is assigned a \emph{suitability degree} by using the formula:
\begin{equation}
 Suitability = w_{SimD} * SimD + w_{SF} * SF
\end{equation}
where $w_i \in [0, 1], \sum w_i = 1$ are weight values that allow the agent to give more or less importance to the similarity degree with the domain-cases used to generate its position or the support factor (these weights can be set in the agent's constructor). Agents sort their potential positions from most to less suitable depending on their value preference order, and for each group of positions that promote the same value, agents sort them by their suitability degree. The most suitable position is selected as the one that the agent is going to propose and defend first.

The argumentation API of Magentix2 includes several \emph{similarity algorithms} to compute the similarity degree (\emph{SimD}) in the \lstinline{SimilarityAlgorithms.java} class. Also, the \lstinline{Metrics.java} class includes several metrics to compute distances between cases, which are used in the similarity algorithms. Table \ref{tab:algorithms} shows these methods, which belong to the \texttt{argAgents} package.

\begin{table}[h!t]
\begin{tabulary}{1\linewidth}{|@{~}l|@{~}l|@{~}L|}
\hline
\textbf{Class} & \textbf{Method} & \textbf{Description} \\ 
\hline
Metrics.java & doDist & This method decides about which is the data type of its attributes, and return the distance between them\\
\hline
Metrics.java & dist & This method calculates the distance between a pair of attributes\\
\hline
SililarityAlgorithms.java & normalizedEuclideanSimilarity & Returns a list of the candidate domain-cases with a similarity degree to the given domain-cases. The similarity is calculated using normalized Euclidean distance among the premises\\
\hline
SililarityAlgorithms.java & weightedEuclideanSimilarity & Returns a list of the candidate domain-cases with a similarity degree to the given domain-cases. The similarity is calculated using weighted Euclidean distance among the premises\\
\hline
SililarityAlgorithms.java & normalizedTverskySimilarity & Returns a list of the candidate domain-cases with a similarity degree to the given domain-cases. The similarity is calculated using normalized Tversky distance among the premises\\
\hline
\end{tabulary}
\caption{Methods to compute the distance and similarity between cases}
\label{tab:algorithms}
\end{table}

The specific algorithm that an argumentative agents uses to compute the similarity degree between two cases can be set in the \lstinline{configuration.xml} file of the \texttt{configuration} package, shown below. 

\begin{lstlisting}
<root>
...
<domaincbr>
	<similarity>normalizedEuclidean</similarity> <!-- normalizedEuclidean or weightedEuclidean or normalizedTversky -->
</domaincbr>
...
</root>
\end{lstlisting}

\underline{SUPPORT ARGUMENTS MANAGEMENT}

A list of possible support arguments is generated with the method \lstinline{generateSupportArguments} by using different combinations of the available support elements in the support set. This list is ordered by using the \emph{suitability degree} explained before and the argument that has the higher degree is proposed first as support argument to justify the agent's position.

\underline{ATTACK ARGUMENTS MANAGEMENT}

To generate an attack argument, the premises that the argument to attack has and the social context between the agents that are arguing are taken into account. With this information, argumentative agents extract the argument-cases that match with the current position and have a similar social context. Then, if the dependency relation allows to attack the other agent, the agent generates the attack argument. The first type of attack that the agent will try to generate is a counter-example attack (with the method \lstinline{generateCEAttack}), and if it is not possible the agent will try to generate a distinguishing premise attack (with the method \lstinline{generateCEAttack}). The counter-example attack consists on an argument that includes a domain-case or an argument-case whose conclusion contradicts the conclusion of the attacked argument. A distinguishing premise attack consists on an argument that includes a premise (or a set) that describes the problem and that the attacked agent did not consider to generate its position (and its associated support argument) or a premise that both agents have, but with different data value. %In the current implementation of the Magentix2 argumentation API, an agent can extract these distinguishing premises by using the description of the knowledge resources that match the description of the problem at hand and that it has used to generate its position (see the \texttt{Argument.java} JavaDoc for more information).

\subsubsection{Argumentation Protocol}
%\textbf{Argumentation protocol}:
Argumentative agents need a protocol to exchange positions and arguments and engage in the argumentation dialogue. The protocol is represented by a set of locutions that the agents use to communicate with each other, and a state machine that defines the behaviour of an agent in the argumentation dialogue. The state machine has been implemented in the \lstinline{ArgCAgent.java} class by overwriting the states of the argumentation protocol of the API. This protocol has been implemented in the \lstinline{Argumentation_Participant.java} abstract class of the \lstinline{cAgents.protocols} package. In each state of the protocol, the different locutions that can be received and generated are taken into account to act in consequence and move to the next state. Inside each state, the corresponding actions are performed using the necessary calls to the different functions of the agent (shown in Table \ref{tab:ArgProtocolMethods} of Section \ref{subsubsec:howToCreate}). Also, argumentative agents can make queries to the commitment store and retrieve information about their argumentation dialogue. Recall that since argumentative agents are a special type of Magentix2 \texttt{cAgents}, agents queue messages and send or receive them in the corresponding \textit{send} and \textit{receive} states (see Section \ref{sec:CAgents}). The behaviour of the commitment store resource has been implemented by overwriting the abstract class \lstinline{CommitmentStore_Protocol.java} of the \lstinline{cAgents.protocols} package in the \lstinline{CommitmentStore.java} class.

The set of allowed locutions of our argumentation protocol are codified as constants in the \texttt{Argumentation\_Participant} protocol of the \lstinline{cAgents.protocols} package. These locutions are the following:
\begin{itemize}
	
%% TODO REVISE LOCUTIONS IN THE IMPLEMENTATION
%% REVISE GETALLPOSITIONS

 \item OPENDIALOGUE: with this locution an agent opens the argumentation dialogue, asking other agents to collaborate or negotiate to solve a problem that it has been presented with.
 \item ENTERDIALOGUE: with this locution an agent engages in the argumentation dialogue to solve the problem. 
 \item WITHDRAWDIALOGUE: with this locution an agent leaves the argumentation dialogue. 
 \item ADDPOSITION: with this locution an agent puts forward its position as its proposed solution to solve the problem under discussion in the argumentation dialogue.
 \item WHY: with this locution an agent challenges the position or the argument of another agent, asking it for a support argument.
 \item NOCOMMIT: with this locution an agent withdraws its position as a solution for the problem under discussion in the argumentation dialogue. 
 \item ASSERT: with this locution an agent sends to another agent an argument that supports its position.
 \item ACCEPT: with this locution an agent accepts the argument or the position of another agent.
 \item ATTACK: with this locution an agent challenges the argument of another agent.
\end{itemize}

Also, there are other allowed locutions to manage the life cycle of argumentative agents and get information from the commitment store:
\begin{itemize}
 \item FINISHDIALOGUE is a locution to inform an agent that it must perform the necessary actions (if any) before withdrawing from the dialogue.
 \item DIE is a locution to inform an agent that it must \emph{shutdown} its execution.
 \item GETALLPOSITIONS is a locution to request the commitment store the list of available positions at a certain step of the dialogue. The commitment store uses the same locution to answer this request.
\end{itemize}

\begin{figure*}[ht]
  \centering
    \includegraphics[width=.9\linewidth]{ProgrammingAgents/images/ArgCAgentGraph.pdf} 
  \caption{Argumentation Protocol}
\label{fig:protocol}
\end{figure*}

Figure \ref{fig:protocol} shows the state machine that defines the behaviour of an agent that follows the Magentix2 \texttt{Argumentation\_Participant} protocol. In the figure, dotted states represent \emph{wait states} where the argumentative agent waits for messages from other agents or the commitment store. Also, dotted lines represent transitions between states when these incoming messages, with their associated locution, are received. Therefore, the transitions between states depend on the locutions that the agent can use in each step of the dialogue. The states of the argumentation dialogue are described as follows:
\begin{enumerate}
 \item \textbf{Begin:} this is the start state of the argumentation protocol.
 \item \textbf{Open:} when the agent is initialised it remains in this state waiting for an \emph{OPENDIALOGUE} locution. The agent will move back to this state when the dialogue has finished. The \emph{OPENDIALOGUE} locution inform the agent that a new dialogue to solve a problem has started. Also, when an agent received the \emph{DIE} locution in this state, it must shutdown its execution.
 \item \textbf{Enter:} in this state, the agent will retrieve such cases of its domain-cases case-base which features match the given problem with a similarity degree greater than a given threshold. If the agent has been able to retrieve similar domain-cases and use their solutions to propose a solution for the current problem the agent will engage in the dialogue with the locution \emph{ENTERDIALOGUE} and will go to the state "Propose". The agent only engages in the dialogue if it has solutions to propose. Otherwise, the agent can refuse to engage in the dialogue with the locution \emph{WITHDRAWDIALOGUE}.
 \item \textbf{Propose:} when the agent is in this state it has retrieved a list of similar domain-cases to the current problem to propose a solution (position to defend). If there are several solutions to propose, it will select the most suitable and go to the state "Central". Otherwise, the agent will leave the dialogue with the locution \emph{WITHDRAWDIALOGUE}.
 \item \textbf{Central:} this is a central state, since the agent can try to attack other positions or defend its position from the attacks of other agents. First, the agent checks if there is any \emph{WHY} request from other agent. This locution is used to ask an argumentative agent to justify its position. In that case, the agent will go to the state "Assert" to try to generate a support argument for its position. If the agent has not received any \emph{WHY} request before a specified \emph{timeout}, it will go to the state "Query Positions" to challenge the positions of other agents. Also, an agent can be reported by other agent that the latter \emph{ACCEPT}s its position. Alternatively, the agent can receive a \emph{FINISHDIALOGUE} locution in this state, and it will go to the state "Send Position" to start the actions to leave the dialogue when it has proposed yet a position.
 \item \textbf{Assert:} the agent that received the \emph{WHY} request will \emph{ASSERT} a support argument to the opponent if it can. This implies going to the state "Wait Attack" and wait for incoming attack arguments. If the agent is not able to provide a support argument to defend its position, it must move back to the state "Propose" with the locution \emph{NOCOMMIT} to withdraw its position from the dialogue and if possible, propose another generated position. Also, argumentative agents do not respond to the same \emph{WHY} query from the same opponent agent twice. In this case, the argumentative agent will move back to the state "Central" and ignore the repeated \emph{WHY} request.
 \item \textbf{Wait Attack:} in this state, the agent that has put forward a support argument for its position waits for an \emph{ATTACK} or an \emph{ACCEPT} locution. In the case that an \emph{ATTACK} is received, the agent will go to the state "Defend" to try to rebut the attack. If the agent receives an \emph{ACCEPT}, it means that the opponent agent has accepted its position and the proponent agent will move back to state "Central".
 \item \textbf{Defend:} in this state, an agent that has received an \emph{ATTACK} from an opponent agent tries to reply with another \emph{ATTACK}. In this case, the proponent agent will move back to the state "Wait Attack" to wait for the response of the opponent agent. However, if the proponent agent is not able to counter-attack, it must move back to the state "Propose" with the locution \emph{NOCOMMIT} to withdraw its position from the dialogue and if possible, propose another generated position.
 \item \textbf{Query Positions:} in this state the agent that has decided to challenge the positions of other agents requests the commitment store the list of current positions proposed in the dialogue with the locution \emph{GETALLPOSITIONS}.
 \item \textbf{Get Positions:} the agent that has requested the commitment store for active positions in the dialogue moves to this state to wait for an answer. Here, the agent can receive the list of positions with the same locution \emph{GETALLPOSITIONS}. Alternatively, the agent can receive a \emph{FINISHDIALOGUE} locution in this state, and it will go to the state "Send Position" to start the actions to leave the dialogue when it has proposed yet a position. Also, if the agent does not receive any response before a specified \emph{timeout}, it will move back again to the state "Central".
 \item \textbf{Why:} in this state, the agent that has received a list of potential positions to challenge makes a random choice to challenge one of them with the locution \emph{WHY} (from these positions that are different to its own). Otherwise, if there are no positions to challenge and ask for a justification, the agent moves back to the state "Central".
 \item \textbf{Wait Assert:} in this state, the agent that has challenged a position waits for a response from the challenged agent. If it receives such a response with the locution \emph{ASSERT}, it tries to rebut the position of the challenged agent and moves to the state "Attack". Otherwise, if the challenged agent cannot provide a justification for its position, it must withdraw such position from the dialogue with the locution \emph{NOCOMMIT} and the challenger moves back to the state "Central". Also, if the agent does not receive any response before a specified \emph{timeout}, it will move again to the state "Central".
 \item \textbf{Attack:} in this state, if an agent has received a justification for a challenged position, it tries to generate an attack with the locution \emph{ATTACK}. In this case, the agent moves to the state "Attack2". However, if it is not able to attack the position, it will accept it with the locution \emph{ACCEPT} and move back to the state "Central".
 \item \textbf{Attack2:} once an agent has generated an attack for the position of a proponent agent, it waits in this state for the answer of the proponent. Thus, if the proponent is able to counter-attack and sends a locution \emph{ATTACK}, the agent will move back to the state "Attack" to try to generate a new attack to rebut the position of the proponent. Otherwise, the proponent must withdraw its position from the dialogue with the locution \emph{NOCOMMIT} and the attacker agent moves back to the state "Central".
 \item \textbf{Send Position:} an agent reaches this state when it has received a locution \emph{FINISHDIALOGUE} to start the actions to leave the dialogue when it has proposed yet a position. Here, the agent sends its current position to update the commitment store information and avoid possible inconsistencies. After that, the agent moves to the state "Solution" to wait for the final solution applied to solve the problem.
 \item \textbf{Solution:} when the dialogue has finished, the final solution to apply is reporter to all dialogue participants. When agents receive this information, they update their case-bases with the data learnt from the dialogue and move back to the state "Open".
 \item \textbf{Die:} this is the final state of the argumentation protocol. Agents move to this state when they receive the locution \emph{DIE} and shutdown their execution.
\end{enumerate}

\subsection{Programming Argumentative Agents}
\label{subsec:howTo}

\subsubsection{How to run Magentix2 Argumentative Agents}
\label{subsubsec:howToRun}

Magentix2 provides a default implementation of an argumentative agent that can be run from the \textit{Magentix2/examples/bin} directory. Thus, the user can execute the \lstinline{Start-Argumentation} \lstinline{Example.sh} script that launches the default argumentation example:

\begin{lstlisting}
cd Magentix2/examples/bin

sh Start-ArgumentationExample.sh
\end{lstlisting}

\begin{table}[h!t]
\begin{tabular}{|l|l|p{5cm}|}
\hline
\textbf{Package} & \textbf{Classes} & \textbf{Description} \\ \hline
\multirow{5}{*}{Argumentation\_Example } & AgentsCreation.java & This class has different methods to create groups of agents and some of their parameters \\ 
 & ArgCAgent.java & This class implements the argumentative agent as a CAgent. It can engage in an argumentation dialogue to solve a problem.  \\ 
 & CreatePartitions.java & This class creates different partitions of domain-cases and argument-cases to make tests \\ 
 & TestArgCAgent.java &  This class launches a test with argumentative agents, including the commitment store and a tester agent that acts as initiator of the dialogue\\ 
 & TesterArgCAgent.java & This class represents a tester agent in charge of sending the test domain-case to solve to a group of agents and acts as the initiator of the dialogue \\ \hline
TestArgumentation (datafiles) & partitionsInc & Folder with the data files to perform tests \\ \hline

\end{tabular}
\caption{Argumentation example packages and classes}
\label{tab:argAgentsExamplePackages}
\end{table}

If the user wants to use a different configuration of the parameters of the example, it is necessary to modify the source code of the example (see Table \ref{tab:argAgentsExamplePackages}). To do it, the user has to use the source code from the \textit{Magentix2/src} directory and create a project to modify the code. The Magentix2 library must be included in the project. The steps to perform this task are explained in Section \ref{sec:devel1stAgent}. In this case, the code to modify is located in the \textit{Argumentation\_Example} package. The main class to execute tests is \textit{TestArgCAgent.java}. In this class, the user can modify the initial data given to the agents, the number of agents to execute, the number of problems to solve and the weights of the argumentative agents to perform different argumentation strategies. The behaviour of the argumentative agents can be changed modifying the default actions of the methods in the \textit{ArgCAgent.java} class (see Table \ref{tab:ArgCAgentMethods}). Furthermore, in the argumentation example provided, we assume the existence of a \emph{tester} agent that is in charge of requesting a group of \emph{ArgCAgents} to solve a problem. This agent, implemented in the Magentix2 argumentation API with the class \v{TesterArgCAgent} extends a Magentix2 \lstinline{SingleAgent}. Also, it is in charge of gathering information at the end of the protocol and convey the final solution proposed.

\begin{table}[h!t]
\begin{tabular}{|l|p{4cm}|p{5cm}|}
\hline
\textbf{Method} & \textbf{Parameters} & \textbf{Description} \\ \hline
generateAttackArgument & incomingArgument, opponentID & Defends and attacks other agents' positions \\ \hline
generatePositions & problem & Evaluates if it can propose a position \\ \hline
generateSupportArguments & myPosition, opponentID & Defends its position \\ \hline
updateCBs & solution &  Stores generated data in the dialogue \\ \hline
\end{tabular}
\caption{Main \textit{ArgCAgent.java} methods}
\label{tab:ArgCAgentMethods}
\end{table}


A standard argumentative agent can be created and executed by using these commands:

\begin{lstlisting}
ArgCAgent agent = 
new ArgCAgent(new AgentID("qpid://agentName@localhost:8080"), 
socialEntity, friendsList, depenRelsList, group, 
"commitmentStoreID", iniDomainCasesFilePath, 
finDomainCasesFilePath, domCBRindex, domCBRthreshold, 
iniArgCasesFilePath, finArgCasesFilePath, 
wPD, wSD, wRD, wAD, wED, wEP);  

agent.start();	
\end{lstlisting}

where \emph{socialEntity} represents the social entity (name, role, preference values...) created for this agent, \emph{friendsList} is an \lstinline{ArrayList} with the social entities that represent the friends of the agent (the agents that it knows), \emph{depenRelsList} is an \lstinline{ArrayList} that represents the dependency relations that the agent has with the rest of agents of the system, \emph{group} represents the group that the agent belongs and \emph{commitmentStoreID} represents the identifier of the commitment store resource. There are also two \lstinline{ArrayList} called \textit{iniDomainCasesFilePath} and \textit{finDomainCasesFilePath} with the file paths that store the initial and final domain-cases case-bases. In addition, \emph{domCBRindex} establishes an index (in the sense of a \lstinline{HashTable} index) to retrieve cases from the domain-cases case-base and \emph{domCBRthreshold} establishes a threshold over which two cases are considered as similar. The \textit{iniArgCasesFilePath} and \textit{finArgCasesFilePath} \lstinline{ArrayLists} represent the file paths that store the initial and final argument-cases case-bases. Finally, the \emph{wPD}, \emph{wSD}, \emph{wRD}, \emph{wAD}, \emph{wED} and \emph{wEP} are the weights assigned to the parameters to compute the \emph{supportFactor}. Different combinations of these weight allow argumentative agents to follow different argumentation strategies.

% The fist step to run the application is to launch the Magentix2 platform. This can be done by executing with root permissions the following command in an ubuntu system:
% 
% \begin{lstlisting}
% root-user@host:~/MagentixRoute/bin\$sh Start-Magentix.sh
% \end{lstlisting}
% 
% Similarly, the platform can be shutdown by executing with root permissions the following command in an ubuntu system:
% 
% \begin{lstlisting}
% root-user@host:~/MagentixRoute/bin\$sh Stop-Magentix.sh
% \end{lstlisting}
% 
% Then, the easiest way of running the application is to create a \emph{test} java file with the code to execute the agents. In the Magentix2 argumentation API an example of such file is distributed with the java file \texttt{TestArgCAgent.java}. The main method of the \emph{test} file must set the information of the Magentix2 logger service with the agent class that we want to log:
% 
% \begin{lstlisting}
% DOMConfigurator.configure("configuration/loggin.xml");
% Logger logger = Logger.getLogger(TestArgCAgent.class);
% \end{lstlisting}
% 
% Also, it must connect the \emph{QPid} broker
% 
% \begin{lstlisting}
% AgentsConnection.connect();
% \end{lstlisting}
% 
% In the \emph{test} file the identifier of the \emph{Tester} agent must be specified. Assuming that the identifier is \emph{testerAgent}, it is set as follows:
% 
% \begin{lstlisting}
% String testerAgentID = "testerAgent";
% \end{lstlisting}
% 
% In the current version of the software, when the problem-solving process finishes and the \emph{Tester} agent decides the best solution to apply from the list of candidates, it reports the end of the process by writing a message "test finished" in a \emph{finish file}. In this way, the execution of the program ends. This simple design decision allows us to be sure that all agents have died and the \emph{tester} agent has reported the final solution for the problem at hand. Therefore, the name of this file must be specified in the \emph{test} file as follows:
% 
% \begin{lstlisting}
% String finishFileName = 
% "testArgumentation/testArgCAgentFinished";
% \end{lstlisting}
% 
% We are persisting the cases of the domain case-base and argumentation case-base as serialised objects. Thus, we must specify the route of these files in the agent's constructor (the original files to read and also the final files to persist the new data acquired):
% 
% \begin{lstlisting}
% ArrayList<String> iniDomainFiles=new ArrayList<String>();
% ArrayList<String> finDomainFiles=new ArrayList<String>();
% ArrayList<String> iniArgFiles=new ArrayList<String>();
% ArrayList<String> finArgFiles=new ArrayList<String>();
% \end{lstlisting}
% Then, for each agent to create, the route of the files must be specified:
% 
% \begin{lstlisting}
% iniDomainFiles.add("route/iniDomainFile.dat");
% finDomainFiles.add("route/finDomainFile.dat");
% iniArgFiles.add("route/iniArgFile.dat");
% finArgFiles.add("route/finArgFile.dat");
% \end{lstlisting}
% The original files to read and the final files to persist the new data acquired can be the same or different from the originals. By default, in the \texttt{TestArgCAgent.java} file we assume that they are the same.
% 
% The social entities of the system, the argumentative agents and the commitment store must be also initialised in the \emph{test} file. The argumentation API of Magentix2 includes a template java file called \texttt{AgentsCreation.java} with several methods to create groups of agents and their parameters (see the JavaDoc for a detailed explanation of this class). Therefore, the social entities of the system can be initialised (one per each agent and each group) as follows:
% 
% \begin{lstlisting}
% ArrayList<SocialEntity> socialEntities=
% 	new ArrayList<SocialEntity>();
% SocialEntity socialEntity=
% 	new SocialEntity(i, "entityName", norms, preferredValues); 
% socialEntities.add(socialEntity);  
% ...  
% Group group = new Group(ID, "GroupName", preferredValues, socialEntitiesAssociated)
% \end{lstlisting}
% 
% where \emph{norms} is an \emph{ArrayList} of the norms that the entity has to obey and \emph{preferredValues} is an object of the type \emph{ValPref} that establishes the preferences over values that the entity has.
% 
% As explained, to facilitate the communication with the agents, the commitment store resource has to be created as a Magentix2 \texttt{CAgent}:
% 
% \begin{lstlisting}
% CommitmentStore commitmentStore =  
% new CommitmentStore(new AgentID("qpid://commitmentStore@
% localhost:8080")); 
% commitmentStore.start();
% \end{lstlisting}
% 
% A standard argumentative agent can be created and executed by using these commands:
% 
% \begin{lstlisting}
% ArgCAgent agent = 
% 	new ArgCAgent(new AgentID("qpid://agentName@localhost:8080"), 
% 	socialEntity, friendsList, 
% 	depenRelsList, group, "commitmentStoreID", 
% 	testerAgentID, iniDomainCasesFilePath, 
% 	finDomainCasesFilePath, domCBRindex, 
% 	domCBRthreshold, iniArgCasesFilePath, 
% 	finArgCasesFilePath, wPD, wSD, wRD, wAD, wED, wEP);  
% agent.start();	
% \end{lstlisting}
% 
% where \emph{socialEntity} represents the social entity created for this agent, \emph{friendsList} is an \texttt{ArrayList} with the social entities that represent the friends of the agent, \emph{depenRelsList} is an \texttt{ArrayList} that represents the dependency relations that the agent has with the rest of agents of the system, \emph{group} represents the group that the agent belongs, \emph{commitmentStoreID} represents the identifier of the commitment store resource, \emph{testerAgentID} allows the user to specify the identifier of this special agent that is implemented in the system to process and show data. In addition, \emph{domCBRindex} establishes an index to retrieve cases from the domain-cases case-base, \emph{domCBRthreshold} establishes a threshold over which two cases are considered as similar and \emph{wPD}, \emph{wSD}, \emph{wRD}, \emph{wAD}, \emph{wED} and \emph{wEP} are the weights of the elements to compute the \emph{supportFactor}. As explained before, the name of the files where domain-cases and argument-cases are persisted are also specified in the \texttt{ArgCAgent} constructor.
% 
% Finally, the \emph{test} file must create and initialise the \emph{tester} agent and send to it the problem to solve. Magentix2 argumentation API includes a template of a \emph{tester} agent in the java file \texttt{TesterArgCAgent.java} (see the JavaDoc for a detailed explanation of this class).
% 
% \begin{lstlisting}
% TesterArgCAgent testerAgent = 
% 	new TesterArgCAgent(new AgentID("qpid://agentName@
% 	localhost:8080"), socialEntities, commitmentStoreID, 
% 	resultsFileName, finishFileName, cases, repetition, 
% 	domCasesVector, agents);
% testerAgent.start();	
% \end{lstlisting}
% 
% where \emph{socialEntities} is an \texttt{ArrayList} with the \emph{social entities} of the dialogue, \emph{commitmentStoreID} is the identifier of the commitment store, \emph{resultsFileName} is the name of the file to save the results of the program execution, \emph{finishFileName} is the name of the file to write when the problem-solving process is finished, \emph{cases} is the number of domain-cases that each argumentative agent has (this number is used to compute performance results), \emph{repetition} is a variable to specify the number of runs of the problem-solvin process (each one trying to solve a different problem), \emph{domCasesVector} is a \texttt{Vector} with cases used as problems to solve (in the current implementation of the software, it only includes one problem to solve per run) and \emph{agents} is the \texttt{ArrayList} of \texttt{ArgCAgent}s participating in the argumentation dialogue to solve the problem.


\subsubsection{How to create your own Magentix2 Argumentative Agent}
\label{subsubsec:howToCreate}

Magentix2 provides the core of the argumentation protocol, the Domain CBR, the Argumentation CBR and the knowledge resources (see Table \ref{tab:argAgentsCore}) needed to crete your own argumentative agent (and not directly using the default argumentative agent provided in the \textit{Argumentation\_Example}).

\begin{table}[h!t]
\begin{tabular}{|l|l|p{5cm}|}
\hline
\textbf{Package} & \textbf{Classes} & \textbf{Description} \\ \hline

\multirow{7}{*}{argAgents}  & argCBR.ArgCBR.java & This CBR stores argument-cases that represent past argumentation experiences and their final outcome \\ 
 & CommitmentStore.java & Agent that stores all the information about the argumentation dialogues \\
 & Configuration.java & Configuration parameters \\ 
 & domCBR.DomainCBR.java &  This CBR stores domain knowledge of previously solved problems \\ 
 & knowledgeResources &  Package that contains the classes needed to manage the data of the CBRs and arguments \\ 
 & Metrics.java & Used by the CBRs to measure the similarity between case attributes, based on their distance \\ 
 & SimilarityAlgorithms.java & Contains algorithms to calculate similarity measures between cases \\ \hline
\multirow{2}{*}{cAgents.protocols} & Argumentation\_Participant.java & Abstract class that defines the argumentation participant protocol to be followed by the CAgents \\ 
 & CommitmentStore\_Protocol.java & Abstract class that defines the protocol that the Commitment Store follows to attend the petitions of the agents \\ \hline

\end{tabular}
\caption{Argumentative agents core packages and classes}
\label{tab:argAgentsCore}
\end{table}

The main tasks to perform to create an argumentative agent are: 
\begin{itemize}
 \item To use the Domain CBR to store and retrieve domain knowledge.
 \item To use the Argumentation CBR to store and retrieve argumentation knowledge.
 \item To implement the argumentation protocol methods and thus, specify how to perform the actions of the argumentative agent in the states of the designed argumentation protocol.
\end{itemize}

The Domain CBR can be used to generate and select positions to defend in the argumentation dialogue. To make a query to the domain CBR, the user has to provide a problem (codified as a list of premises or a domain-case without solution) and a threshold of similarity. The domain CBR module searches the domain case-base and returns a list of similar domain-cases to the given problem. In addition, with every request attended and every CBR cycle performed, the module adds, modifies or deletes one or more domain-cases of the domain case-base. In the current version of the API, if the problem that has been solved is similar enough (over certain similarity threshold) to a case of the domain-cases case-base, the update algorithm updates this case with the new data acquired. Otherwise, a new domain-case is created and added to the case-base. 
%Also, this CBR can be updated with the generated data during the argumentation process adding the learnt cases. 
The main methods of the Domain CBR are shown in Table \ref{tab:DomainCBRMethods} (for a detailed explanation of all Domain CBR methods, see the \lstinline{DomainCBR.java} associated JavaDoc).
\begin{table}[h!t]
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Method} & \textbf{Parameters} & \textbf{Description} \\ \hline
addCase & domain-case & Adds a new domain-case to domain case-base. Otherwise, if the same domain-case exists in the case-base, adds the relevant data to the existing domain-case \\ \hline
getPremisesSimilarity & premises1, premises2 & Obtains the similarity between two HashMap of premises using the similarity algorithm specified in the configuration of this class \\ \hline
retrieve & premises, threshold & Retrieves the most similar domain-cases to the given premises with a similarity degree greater or equal than a given threshold \\ \hline
\end{tabular}
\caption{Main \textit{DomainCBR.java} methods}
\label{tab:DomainCBRMethods}
\end{table}

The Argumentation CBR can be used to look for previous argumentation experiences and use this knowledge to select the best positions and arguments to propose. Thus, argument-cases store information related to the domain and the social context where previous arguments (and their associated positions) were used. The information about the domain consists of a set of features (premises) to compare cases and information about the social context where the proposed solution was applied (e.g. the agents that participated in the dialogue to solve the problem, their roles or their value preferences). The latter information can determine if certain positions and arguments are more persuasive than others for a particular social context and hence, agents can select the best ones to propose in the current situation. As for the domain-cases case-base, if the argument-cases created during the problem solving process are similar enough to previous argument-cases stored in the argument-cases case-base, the update algorithm updates those cases with the new data acquired. Otherwise, new argument-cases are created and added to the case-base.
%The Argumentation CBR has to be used to select the positions to defend (using also the Domain CBR) and to generate and select support and attack arguments in the argumentation dialogue. This CBR may be updated with the argumentation knowledge generated during the argumentation process to learn about how to argue. 
The main methods of the Argumentation CBR are shown in Table \ref{tab:ArgCBRMethods} (for a detailed explanation of all Argumentation CBR methods see the \lstinline{ArgCBR.java} associated JavaDoc).

\begin{table}[h!t]
\begin{tabular}{|p{4cm}|p{3cm}|p{6cm}|}
\hline
\textbf{Method} & \textbf{Parameters} & \textbf{Description} \\ \hline
addCase & argument-case & Adds a new argument-case to the case-base. Two cases are considered equal if they have the same domain context, social context, conclusion and status of acceptability \\ \hline
getDegrees & argumentProblem, solution, allPositions, index & Return a list with the degrees (attack, efficiency, explanatory power, persuasiveness, support and risk) of an argument-case \\ \hline
getSameDomainAnd\-SocialContextAccepted & premises, solution, socialContext & Returns the argument-cases with the same domain and social context that have been accepted in the past \\ \hline
\end{tabular}
\caption{Main \textit{ArgCBR.java} methods}
\label{tab:ArgCBRMethods}
\end{table}

The contents of the case-bases of the Domain CBR and the Argumentation CBR can be stored as java serialised objects. In this way, we provide a quick and simple data persistence mechanism. Thus, both \lstinline{DomainCBR.java} and \lstinline{ArgCBR.java} classes include different methods to load and save information about cases from/to data files, see Table \ref{tab:CBRPersistenceMethods}.
\begin{table}[h!t]
\begin{tabular}{|l|p{11cm}|}
\hline
\textbf{Method} &  \textbf{Description} \\ \hline
doCache &  Stores the current domain-cases case-base in a specified file path \\ \hline
doCacheInc &  Stores the current domain-cases case-base in a specified file path, but keeping the contents of that file \\ \hline
loadCaseBase &  Loads a case-base stored in a specified file path \\ \hline
\end{tabular}
\caption{Main CBR persistence methods}
\label{tab:CBRPersistenceMethods}
\end{table}

The main functionalities of the argumentative agents (generation, selection and evaluation of positions and arguments) are specified as methods, to facilitate a better understanding of the code and to facilitate modifications and updates. The main method of the argumentative agents is the \lstinline{execution} method. This method overwrites the \lstinline{execution} method of the Magentix2 \texttt{CAgent}, implementing the argumentative functions of the agent. Inside the \lstinline{execution} method, the \lstinline{myArgumentation} class extends the argumentation protocol of Magentix2. Concretely, the argumentation API of Magentix2 includes two special protocols that allow agents to argue: the \texttt{Argumentation\_Participant} protocol and the \texttt{CommitmentStore\_Protocol}. Both are abstract classes of the \lstinline{cAgents.protocols} package that argumentative agents and the commitment store extend respectively. These classes provide a template for the behaviour of the argumentative agents and the commitment store. Each one implements a new \texttt{CFactory} (see \texttt{CAgent} JavaDoc for more information) with the graph that specifies the sequence of states and transitions among them that agents can pass through during the argumentation dialogue. 

Therefore, to create a new argumentative agent, it is necessary to implement the abstract methods of the \texttt{Argumentation\_Participant} protocol. The decisions and the actions to perform in each state of the argumentation protocol are codified in these methods. The main methods to implement are shown in Table \ref{tab:ArgProtocolMethods}. Due to the complexity of defining a new argumentative agent, the user should consider to use the \textit{ArgCAgent.java} class of the example as a base to implement the behaviour of a new argumentative agent.

\begin{table}[h!t]
\begin{tabulary}{1\linewidth}{|l|L|}
\hline
\textbf{Method} & \textbf{Description} \\ \hline
doAccept & actions to perform and send an \textit{ACLMessage} accepting the other agent's position or argument \\ \hline
doAssert & try to assert a support argument to respond to the \textit{WHY} received previously \\ \hline
doAttack & actions to perform to generate an attack argument against an attack or assert received \\ \hline
doDie & actions to perform when the message with locution \textit{DIE} is received \\ \hline
doEnterDialogue & evaluates if the agent can enter in the dialogue offering a solution \\ \hline
doFinishDialogue & actions to be executed when the dialogue has to finish \\ \hline
doGetPositions & get the positions of the agents in the dialogue sent by the Commitment Store as an object \\ \hline
doMyPositionAccepted & actions to perform when the position of the agent has been accepted \\ \hline
doNoCommit & creates an \textit{ACLMessage} to send with the locution \textit{NOCOMMIT} \\ \hline
doOpenDialogue & takes the domain-case to solve and the dialogue ID from the received \textit{ACLMessage} given \\ \hline
doPropose & proposes a position to defend in the dialogue. If it can not, it does a \textit{WITHDRAWDIALOGUE} \\ \hline
doQueryPositions & creates a message to send to the Commitment Store with locution \textit{GETALLPOSITIONS} to obtain all the positions of the dialogue \\ \hline
doSendPosition & sends an \textit{ACLMessage} with the position defended by the agent \\ \hline
doSolution & actions to perform when the final solution to the current problem to solve arrives in an \textit{ACLMessage} \\ \hline
doWhy & choose a position to send a \textit{WHY} message if it can \\ \hline

\end{tabulary}
\caption{Methods to implement in the Argumentation Protocol}
\label{tab:ArgProtocolMethods}
\end{table}

\subsubsection{Example: Call Centre Application}
\label{subsubsec:callCentre}

To date, the system is implemented in the domain of a customer support application where several operators represented by software agents argue to provide the best solution for an incidence (also known as \emph{ticket}) received. Thus, we use this example domain to show how \texttt{ArgCAgent}s can be executed. Int the current version of the software, the example is implemented in the \texttt{Argumentation\_Example} package, which includes the java files for creating agents (\lstinline{AgentsCreation.java}), the template code of the argumentative agent (\lstinline{ArgCAgent.java}), a file to create case-bases with data about example domain-cases and argument-cases (\lstinline{CreatePartitions.java}), a \emph{test} file for executing the example (\lstinline{TestArgCAgent.java}) and a file with a template of the \emph{tester} agent (\lstinline{TesterArgCAgent.java}). In this section we provide a brief explanation of this example. Details of the implementation can be found in the JavaDoc of the files of the package.

\begin{figure}
  \centering
    \includegraphics[width=0.8\linewidth]{ProgrammingAgents/images/callCenter}
  \caption{Data-flow for the argumentation process of the helpdesk application}
\label{fig:callcentre}
\end{figure}

In order to show how the developed system works, the data-flow for the problem-solving process (or argumentation process) to solve each problem is shown in Figure \ref{fig:callcentre} and described below (arrows in the figure are labelled with the number of the data-flow step that they represent):
\begin{enumerate}
 \item First, we have some argumentation agents running in the platform and representing the technicians of the call centre. The \emph{tester} agent sends the problem to solve (also known as \emph{ticket} in the common call centre terminology) to the group of agents.
 \item Each agent evaluates individually if it can engage in the dialogue offering a solution. To do that, the agent makes a query to its domain CBR to obtain potential solutions to the ticket based on previous solutions applied to similar tickets. To compute such similarity, agents use a \emph{weighted Euclidean} algorithm that searches their domain-cases case-bases for previous problems that semantically match the category of the current ticket to solve. Thus, the algorithm retrieves all problems of the same category and of related categories and select those that syntactically match (assign the same values to the attributes that match the ticket attributes) and overpass a defined \emph{similarity threshold}. If one or more valid solutions can be generated from the selected domain-cases, the agent will be able to defend a position in the dialogue. We consider a valid solution any domain case from the domain CBR with one or more solutions and with a similarity degree greater than the given threshold. Moreover, the agent makes a query to its argumentation CBR for each possible position to defend. With these queries the \emph{suitability degree} of the positions is obtained. This degree represents if a position will be easy to defend based on past similar argumentation experiences. Then, all possible positions to defend are ordered from less to more suitability degree.
 \item When the agents have a position to defend (a proposed solution), these positions are stored by the commitment store, such that other agents can check the positions of all dialogue participants. Every agent tries to attack the positions that are different from its position. 
 \item The argumentation process consists on a series of steps by which agents try to defend its positions by generating counter-examples and distinguishing premises for the positions and arguments of other agents. A counter-example for a case is generated by retrieving from the domain case-base another case that matches the features of the former, but has a different conclusion. Similarly, distinguishing premises are computed by selecting such premises that the agent has taken into account to generate its positions, but that other agents did not considered. If different attacks can be generated, agents select the best attack to rebut the position of another agent by making a query to their argument-cases case-base, extending the characterisation of each case with the current social context. In this way, agents can gain knowledge about how each potential attack worked to rebut the position of an agent in a past argumentation experience with a similar social context. When an agent is able to rebut an attack, the opponent agent makes a vote for its position. Otherwise, the agent must withdraw its position and propose an alternative position, if possible.
 \item The dialogue finishes when no new positions or arguments are generated after a specific time. The \emph{tester} agent is in charge of making queries to the commitment store agent to determine if the dialogue must finish. Then, this agent retrieves the active positions of the participating agents. If all agents agree, the solution associated to the agreed position is selected. Otherwise, the most frequent position wins. In case of draw, the most voted position in selected. If even in this case the draw persists, a random choice is made. Finally, the \emph{tester} agent communicates the final solution (the outcome of the agreement process) to the participating agents.
 \end{enumerate}

   


%==================================================================
%================== SEPTIMA SECCIÓN ===============================
%==================================================================
\section{Launching agents with security enabled}
\label{sec:securityenable}


In order to ensure the integrity, confidentiality, privacity, no repudiation and mutual authentication of the agent comunications, a security module for Magentix2 platform was implemented. 
If the security module is enabled in the platform in which will connect, setting the public key infraestructure and configuring the security properties are necessary.

The basic elements of this public key infrastructure are:

\begin{itemize}

\item \textbf{Asymetrical key-pair:} This is used to sign and encrypt information messages.
\item \textbf{X.509 Certificate:} This is a self-signed certificate with the information of the user, which guarantees the user identity.
\item \textbf{keystore:} It is a file that contains the X.509 User Certificates, which is needed to connect with the platform. The keystore is protected by a password, 
hence this file must never be disclosed to others.
\item \textbf{Trustore:} It is a file that contains a list of trusted parties. The trusted parties will be the Magentix2 platform to which the user connect.
\end{itemize}



\subsection{Creating key-pair}

If a key-pair and a certificate issued by a public entity (must be trusted for the platform) is available, the explanation continues in the section \ref{sec:importingMMS}, if not, the next steps must be followed.

For generating \footnote{For this purpose the command keytool included in Java Sun JDK is used
.} the key pair, this command must be executed in a linux terminal:
\begin{verbatim}
$ keytool -genkey -alias alias_name -keyalg RSA \
		-dname "CN=alias_name,O=Magentix" \
		-storepass mysecretpassword \
		-keypass mysecretpassword \
		-keystore keystore.jks
\end{verbatim}

The result of this command is a new keystore with an  asymmetrical key-pair user and X.509 Certificate.

\subsection{Exporting User Certificate}
For one mutual authentication between the user and platform, a self-signed certificate that contains the user public key must be exported.

\begin{verbatim}
$ keytool -export -keystore keystore \
   -storepass mysecretpassword \
	 -alias alias_name -file user.crt
\end{verbatim}

%\begin{verbatim}
%$ keytool -export -keystore keystore -storepass mysecretpassword  \
%	 -alias alias_name -file user.crt
%\end{verbatim}

The file user.crt will be transfered to the Magentix2 platform administrator by http, ftp, e-mail, etc..., in order that he adds in it his trusted store. 


\subsection{Importing MMS Certificate}
\label{sec:importingMMS}

This command append the Magentix Manager Service (MMS) trusted certificate in the keystore:
\begin{verbatim}
$ keytool -import -trustcacerts -noprompt -alias MMS \
	-file mms.crt -storepass mysecretpassword  -keystore keystore
\end{verbatim}

The file mms.crt contains the MMS public key, to obtain this file, please contact with the Magentix2 administrator.


\subsection{Creating and importing truststore}

If the MagentixCA self-signed certificate is not included in the truststore, the connections with the platform will be rejected. 

The following command creates a truststore and appends the MagentixCA trusted certificate:
\begin{verbatim}
$ keytool -import -trustcacerts -noprompt -alias MagentixCA \
	-file rootca.crt -storepass mysecretpassword \
	-keystore truststore.jks
\end{verbatim}

The root.crt file contains the MagentixCA public key, to obtain this file, please contact with the Magentix2 platform administrator.



\subsection{Configuration}
\label{sec:configuration}

The security parameters must be indicated inside the securityUser.properties file and the configuration of the broker connection inside the Settings.xml. These files are inside the configuration directory.

\begin{itemize}
 \item \textbf{securityUser.properties}

 


The securityUser.Properties is divided into four sections. In the first section, the keystore and truststore is configured, hence the path and password must be specified, as it can be shown in the following example (Figure \ref{fig:1stsecurityUserProp} ).

\begin{figure}[h]
\begin{codigo}
    #<!-- User Security Properties -->
    # set the base path for accessing keystore user
    KeyStorePath=/full_path/keystore.jks

    #set the password to keystore
    KeyStorePassword=password

    # set the base path for accessing truststore user
    TrustStorePath=/full_path/truststore.jks

    #set the password to truststore
    TrustStorePassword=password
\end{codigo}

\caption{First section of the securityUser.properties file }
\label{fig:1stsecurityUserProp}
\end{figure}

In the second section it is indicated if the user certificate used has been issued by a public certificate autorithy (in this case the parametre type is \textit{others}) or have been created by the user (the type is \textit{own}).

If the type selected is \textit{others}, then it is required to configuring the parameters that will be find below the \textit{type} parameter. Again, an example is shown below (Figure \ref{fig:2ndsecurityUserProp}).

\begin{figure}[h!]
\begin{codigo}
    #set the type of certificates (own or others (FNMT, ACCV,
    # ...))
    type=own
    #set the base path for access to correct keystore
    othersPath=/full_path/keystore_fnmt.p12
    #set the pin of the smartcard or password of your keystore
    othersPin=password
    #set the type of the keystore
    othersType=PKCS12
\end{codigo}

\caption{Second section of the securityUser.properties file }
\label{fig:2ndsecurityUserProp}
\end{figure}


In the section three (Figure \ref{fig:3rdsecurityUserProp}), the MMS direction path is indicated. For this purpose it is necessary to consult with the Magentix2 administrator to provide the direction ([protocol] + [host] + [port] + [path]) where the MMS service is deployed. 

\begin{figure}[h!]
\begin{codigo}
    # set the connection protocol to be used to access services
    protocol=http
    # set the name of the service host
    host=localhost
    # set the port for accessing the services
    port=8080
    # set the base path for accessing to services
    path=/MMS/services/MMS
\end{codigo}
\caption{Third section of the securityUser.properties file }
\label{fig:3rdsecurityUserProp}
\end{figure}

The purpose of last section is to indicate the user alias certificate (Figure \ref{fig:4thsecurityUserProp}).

\begin{figure}[h!]
\begin{codigo}
#set the alias to user certificate. This alias is
#a PrivateKeyEntry.
alias=[User_alias]
\end{codigo}
\caption{Fourth section of the securityUser.properties file }
\label{fig:4thsecurityUserProp}
\end{figure}

\newpage
If the name of the alias certificate is not know, then it can be consulted with the following command:

\begin{verbatim}
$ keytool -list -keystore keystore.jks 
\end{verbatim}
In the case the certificate store is not a jks type: 
\begin{verbatim}
$ keytool -list -storetype pkcs12 -keystore keystore_fnmt.p12
\end{verbatim}

The alias will be displayed in the first place of line, for example in the following case the alias is \textit{alice} (Figure \ref{fig:keytoolRes}).

\begin{figure}[h!]
\begin{codigo}
Keystore type: JKS
Keystore provider: SUN

Your keystore contains 5 entries

alice, 27-sep-2010, PrivateKeyEntry, 
Hash of certificate (MD5): 
 13:D2:8F:3A:F3:2B:C9:D9:CC:6B:A8:C0:DB:7D:DA:FA
\end{codigo}
\caption{Result of the \textit{Keytool} command}
\label{fig:keytoolRes}
\end{figure}

\newpage

\item \textbf{Settings.xml}
The connection parameters must be specified inside the Settings.xml file. The Figure \ref{fig:settingsxmlfile} shows an example of the content of this file. Note that the \textit{port} parameter is where the broker Qpid is listening to the ssl connections and EXTERNAL is the method by default.


\begin{figure}
\begin{codigo}
    <!-- Properties qpid broker -->
    <entry key="host">localhost</entry>
    <entry key="port">5671</entry>
    <entry key="vhost">test</entry>
    <entry key="user">guest</entry>
    <entry key="pass">guest</entry>
    <entry key="ssl">true</entry>
    <!-- Secure qpid properties -->
    <entry key="secureMode">true</entry>
    <entry key="saslMechs">EXTERNAL</entry>
\end{codigo}
\caption{An example of the Settings.xml file}
\label{fig:settingsxmlfile}
\end{figure}


\end{itemize}

\subsection{Running}

In the secure mode, agent connection with the broker is formed automatically in the agent constructor. Therefore, in the main program, the 
method connect (explained in section \ref{subsec:connecting}) is not necessary. Thus, it is only required to complete carefully the previous configurations
and import the required libraries \footnote{The libraries are available in lib/security/ directory} in the Java project build path.


(Please note that the platform do not allow agents with the same name and it is case sensitive.)

\subsection{Problems}
The following  exceptions can arise when security is used and correct configuration has not be done.
\begin{enumerate}

\item  \textbf{(WSSecurityEngine: Callback supplied no password for: mms).}
The MMS self-signed certificate has not been imported correctly in keystore.
\item  \textbf{org.apache.axis2.AxisFault: Error in signature with X509Token.}
The alias parameter  of the  securityUser.properties file has not correctly specified.
\item  \textbf{General security error (No certificates were found for decryption (KeyId)).}
The MMS self-signed certificate has not been imported correctly in the keystore.
\item  \textbf{org.apache.axis2.AxisFault: The certificate used for the signature is not trusted.}
The User certificate with the user public key has not been added in the truststore of magentix administrator, it is necessary to check that 
the user certificate have been exported and transfered correctly or contact with the magentix administrator.
In administrator mode, section \ref{sec:AddthirdParty} explains how to import user certificate. 
\end{enumerate}

%==================================================================
%================== OCTAVA SECCIÓN ================================
%==================================================================

\section{Tracing Service}
\label{sec:tracingService}
	This section describes the Tracing Service Support available in Magentix2.
	This Tracing Service Support allows agents in a Multiagent System (MAS) share information in an
	indirect way by means of trace events.
	
	Before describing the API provided by Magentix2 to share tracing information, the following sections
	will present TRAMMAS, the trace model which was followed to incorporate event tracing facilities to
	Magentix2.
	
%\begin{enumerate}
% \item \begin{verbatim}AquÃ­ si tenemos que poner cÃ³digo \end{verbatim}
%\end{enumerate}

\subsection{Trace Model and Features}

	The trace event model incorporated to Magentix is described in detail in \cite{Burdalo10}.
	This section will comment briefly the main characteristics of the model and those of its features which
	have been incorporated to the platform.

	The trace model described in \cite{Burdalo10} offers any entity in the system (active or
	passive) the possibility to share information, in the form of trace events, with other entities in the
	system. From the point of view of the trace model, entities in the system are seen as \textit{tracing
	entities}; this is, entities which are able to generate and/or receive trace events. Trace events are
	offered by tracing entities as different \textit{tracing services}, which can be requested by interested
	tracing entities when they want to receive these trace events.
	
	\subsubsection{Supported Features}
	
		The present version of Magentix2 does not support all of the tracing features considered in the
		model. Those which are not yet supported will be incorporated in future versions of the platform.
		
		\begin{itemize}
		
		\item{Tracing Entities}
	
			Although the model considers not only agents, but also non-agent entities or aggregations,
			event tracing facilities incorporated to the present version of Magentix2 platform only
			consider agents. Artifacts and aggregations will be included in future versions of the
			platform.
			
		\item{Publication and Subscription}
		
			Publication and unpublication of trace events is completely supported in the present version
			of the platform; so, tracing entities can dynamically (at run time) publish the event types
			which they can throw and unpublish them when they do not want to share that information
			anymore.
			
			In the same way, tracing entities can dynamically subscribe to trace events in which they are
			interested and unsubscribe from them whenever they do not want to receive these trace
			events anymore. However, although the model lets tracing entities filtering trace events
			according to many parameters, the present version of Magentix2 only allows agents to filter
			trace events according to the event type and the agent which threw the event.
			
			Tracing services composition has also been postponed for later platform releases and thus,
			it is not supported in the present version of Magentix2.
			
		\item{Authorization}
	
			Security issues addressed by the model have also been postponed for future versions of the
			platform and they are not considered in this version. Thus, any agent in the system can
			request trace events from any other agent without needing any direct or indirect
			authorization.
			
		\end{itemize}

%\subsection{Tracing Entity}

%	\begin{lstlisting}
%public class TracingEntity implements Serializable {
%   private int type;
%   private AgentID aid;
%   private TracingServiceList publishedTS;
%   private TracingServiceSubscriptionList subscribedToTS;
%}
%	\end{lstlisting}
%	
%	\begin{itemize}
%		\item\textbf{\texttt{type}:} Tracing entity type:  \texttt{TracingEntity.AGENT},
%			\texttt{TracingEntity.ARTIFACT} or \texttt{TracingEntity.AGGREGATION}.
%			
%		\item\textbf{\texttt{aid}:} AgentID of the tracing entity. This attribute only has sense when the
%			tracing entity is an agent (\texttt{type == TracingEntity.AGENT}).
%			
%		\item\textbf{\texttt{publishedTS}:} List of tracing services published by the tracing entity.
%		
%		\item\textbf{\texttt{subscribedToTS}:} List of tracing services to which the tracing entity is
%			subscribed.
%	\end{itemize}

\subsection{Trace Event}\label{sec:tEvent}

	Trace events are represented in the platform as instances of the class
	\lstinline{es.upv.dsic.gti_ia.core.TraceEvent}:
	
	\begin{lstlisting}
public class TraceEvent implements Serializable {
   private String tService;
   private long timestamp;
   private TracingEntity originEntity;
   private String content;
}
	\end{lstlisting}
	
	The different attributes of this class indentify the \textit{tracing service} to which the trace event
	belongs, the \textit{tracing entity} which originated the trace event and the time at which it was
	produced, expressed as the amount of milliseconds from 1 Jan 1970 at 00:00:00 (\textit{Epoch}).
	This information can be complemented when needed with extra data stored in the
	\texttt{content} attribute.
	
	Trace event instances are created by invoking the constructor of the class. Details of the parameters
	are explained in Table \ref{tab:TraceEvent}. As it can be seen, the \texttt{timestamp} attribute of the
	trace event is not stablished by any parameter of the constructor. This is because the
	\texttt{timestamp} of each trace event is internally set to the time at which the constructor of the class
	was invoked.
	
%	\begin{table}
%	\begin{tabular}
%	
%	\end{tabular}
%	\end{table}
	
	\begin{table}[ht]
       \caption{\texttt{TraceEvent} class constructor parameters}
       \label{tab:TraceEvent}
       \centerline{
%       \small{
       \begin{tabular}{|r|p{11cm}|} \hline
           \multicolumn{2}{|p{14cm}|}{\textbf{\texttt{TraceEvent(String tService, AgentID originAid, String content)}}} \\ \hline \hline
           \textbf{\texttt{tService}:} & String identifying the tracing service to which the trace event is associated. \\ \hline
           \textbf{\texttt{timestamp}:}  & Time at which the trace event was generated. The time is expresed in milliseconds from 1 Jan 1970 at 00:00:00 (\textit{Epoch}).\\ \hline
           \textbf{\texttt{originAid}:} & \texttt{AgentID} of the agent which originated the trace event. Internally, the constructor converts \texttt{originAid} to a \texttt{TracingEntity}.\\ \hline
           \textbf{\texttt{content}:} & Any extra data which could be necessary to complement or understand the meaning of the trace event. This attribute can be empty.\\ \hline
       \end{tabular}
%       }
       }
   \end{table}
	
%	\begin{itemize}
%		\item \textbf{\texttt{public TraceEvent(String tService, AgentID originAid, String content)}}:
%			Creation of a new instance of \texttt{TraceEvent}. The different attributes have to be specified
%			when creating an instance of \texttt{TraceEvent}, except for the \texttt{timestamp}, which is
%			internally set to the current time by an internal call to
%			\\\texttt{java.lang.System.currentTimeMillis()}.
%			
%			\begin{itemize}
%				\item\textbf{\texttt{tService}:} String identifying the tracing service to which the trace event
%					is associated.
%			
%				\item\textbf{\texttt{timestamp}:} Time at which the trace event was generated. The time is
%					expresed in milliseconds from 1 Jan 1970 at 00:00:00 (\textit{Epoch}).
%			
%				\item\textbf{\texttt{originAid}:} \texttt{AgentID} of the agent which originated the trace
%					event. Internally, the constructor converts \texttt{originAid} to a \texttt{TracingEntity}.
%		
%				\item\textbf{\texttt{content}:} Any extra data which could be necessary to complement or
%					understand the meaning of the trace event. This attribute can be empty.
%			\end{itemize}
%	\end{itemize}

	Once created, trace events can be sent by means of the public method
	\lstinline{sendTraceEvent(TraceEvent tEvent)}, included in the class
	\lstinline{es.upv.dsic.gti_ia.core.BaseAgent}. This method does not create the instance of the trace
	event and thus, it is necessary to invoke the \texttt{TraceEvent} constructor before sending it. For
	instance, if an agent wants to create a trace event for a service called \lstinline{SIMPLE_SERVICE},
	it could be made in this way:
	
	\begin{lstlisting}
/* Creation of the trace event */
TraceEvent tEvent = new TraceEvent("SIMPLE_SERVICE", this.getAid(), "This is a simple trace event, provided by a simple tracing service");

/* Sending the event */
send(tEvent);
	\end{lstlisting}
	
%	\begin{itemize}
%		\item \textbf{\texttt{public void sendTraceEvent(TraceEvent tEvent)}}: Throw a trace Event. This
%			method does not set the \texttt{timestamp} attribute of the trace event, which is internally set
%			at creation time by the constructor method.
%			
%			\begin{itemize}
%				\item\textbf{\texttt{tEvent}:} Trace event which is to be thrown.
%			\end{itemize}
%	\end{itemize}

	The class \lstinline{es.upv.dsic.gti_ia.core.BaseAgent} includes a trace event handler method,
	similar to the ACL message handler: \lstinline{onTraceEvent(TraceEvent tEvent)}. This method
	executes automatically each time a trace event is received by the agent; however, it is empty. This
	means that the developer has to write the source code to process trace events.
	
	The source code in Section \ref{sec:daddy} (lines 59 to 79) shows an example of trace event
	handler. In this case, the received trace event is processed attending to its tracing service.

\subsection{Tracing Services}\label{sec:tservices}
	
	Agents which are interested in sharing their trace events, offer them as \textit{tracing services}.
	Agents publish their available tracing services and other agents can request those tracing services
	in which they are interested. As a consequence, only those trace events which have been
	requested by an agent in the system are traced and agents only receive those trace events
	which they have previously requested. In this way, trace event traffic is reduced and agents do
	not have to process trace events which they are not interested in.
	
	In order to register available tracing entities and services, as well as to manage subscriptions to
	tracing services, the platform must have a \textit{Trace Manager} running. In Magentix2, the Trace
	Manager is a single agent (the \texttt{TraceManager} class inherits from \texttt{BaseAgent}), which
	must be running in a host of the platform; however, the trace manager is intended to be a distributed
	entity in future versions of the platform.
	
	The trace manager can be launched in any host where Magentix2 is running by invoking the
	corresponding constructor method \lstinline{TraceManager(AgentID tmAid)}. An example of how to
	launch the Trace Manager can be found in the source code of the example in
	Section \ref{sec:mainapp}, in line number 29 of the main application source code:
	
	\begin{lstlisting}
TraceManager tm = new TraceManager(new AgentID("TM"));
	\end{lstlisting}
	
	Agents communicate with the Trace Manager using the methods available in the class
	\lstinline{es.upv.dsic.gti_ia.trace.TraceInteract}. These methods internally send an ACL message to
	the Trace Manager. This message will be processed by the Trace Manager, which responds to these
	requests via ACL messages to requester agents. When the request sent to the Trace Manager, an
	error ACL message is sent to the requester tracing entity with an error code, in order to let the tracing
	entity know the reason why the request was rejected. These error codes are available in the class
	\lstinline{es.upv.dsic.gti_ia.trace.TraceError} and their meaning is described in Table \ref{tab:error}.
	
	\begin{table}[ht]
     		\caption{Trace Manager error codes}
       		\label{tab:error}
       		\centerline{
%       \small{
       		\begin{tabular}{|r|p{8cm}|} \hline
           		\textbf{\texttt{TRACE\_ERROR}:} & Undefined trace error. \\ \hline
			\textbf{\texttt{ENTITY\_NOT\_FOUND}:} & Tracing entity not present in the system. \\ \hline
			\textbf{\texttt{PROVIDER\_NOT\_FOUND}:} & Provider is not offering the tracing service. \\ \hline
			\textbf{\texttt{SERVICE\_NOT\_FOUND}:} & Tracing service not offered by any tracing
				entity in the system. \\ \hline
			\textbf{\texttt{SUBSCRIPTION\_NOT\_FOUND}:} & Subscription to the tracing service not
				found. \\ \hline
			\textbf{\texttt{ENTITY\_DUPLICATE}:} & Tracing entity already present in the system. \\ \hline
			\textbf{\texttt{SERVICE\_DUPLICATE}:} & Tracing service already offered by the tracing
				entity. \\ \hline
			\textbf{\texttt{SUBSCRIPTION\_DUPLICATE}:} & Subscription already exists. \\ \hline
			\textbf{\texttt{BAD\_ENTITY}:} & Tracing enity not correct. \\ \hline
			\textbf{\texttt{BAD\_SERVICE}:} & Tracing service not correct. \\ \hline
			\textbf{\texttt{PUBLISH\_ERROR}:} & Impossible to publish the tracing service. \\ \hline
			\textbf{\texttt{UNPUBLISH\_ERROR}:} & Impossible to unpublish the tracing service. \\ \hline
			\textbf{\texttt{SUBSCRIPTION\_ERROR}:} & Impossible to subscribe to the tracing service. \\ \hline
			\textbf{\texttt{UNSUBSCRIPTION\_ERROR}:} & Impossible to unsubscribe from the tracing
				service. \\ \hline
			\textbf{\texttt{AUTHORIZATION\_ERROR}:} & Unauthorized to do so. \\ \hline
       		\end{tabular}
%       }
       		}
   	\end{table}
		
	Some of the methods available in \lstinline{es.upv.dsic.gti_ia.trace.TraceInteract} assume that a
	default trace manager called \texttt{TM} is running,
	while others allow specifying the Trace Manager to which requests are to be directed.
	
	Actions related to tracing services can be classified in three main groups, which are explained in
	more detail in the following sections: Publication/Unpublication of tracing services (Section
	\ref{sec:publish}), subscription/unsubscription to/from tracing services (Section
	\ref{sec:subscription}) and listing of tracing entities or services (Section \ref{sec:listing}).
	
%	Tracing services are represented in the platform by the class
%	\texttt{es.upv.dsic.gti\_ia.core.TracingService}:
%	
%	\begin{lstlisting}
%public class TracingService implements Serializable {
%   private String name;
%   private boolean mandatory;
%   private boolean requestable;
%   private String description;
%   private TracingEntityList providers;
%   private TracingServiceSubscriptionList subscriptions;
%}
%	\end{lstlisting}
%	
%	\begin{itemize}
%		\item\textbf{\texttt{name}:} String identifying the tracing service.
%		
%		\item\textbf{\texttt{mandatory}:} Boolean which is set to \texttt{true} when the tracing service
%			cannot be unpublished
%		
%		\item\textbf{\texttt{requestable}:}
%		
%		\item\textbf{\texttt{description}:}
%		
%		\item\textbf{\texttt{providers}:}
%		
%		\item\textbf{\texttt{subscriptions}:}
%	\end{itemize}

		\subsubsection{Tracing service publication}\label{sec:publish}
		
			In order to publish and unpublish tracing services, agents have to use respectively the
			methods \lstinline{publishTracingService} and \lstinline{unpublishTracingService}. These
			methods are described in more detail in Table \ref{tab:publish}.
		
		\begin{table}[ht]
     		\caption{Tracing service publication and unpublication methods}
       		\label{tab:publish}
       		\centerline{
%       \small{
       		\begin{tabular}{|r|p{11cm}|} \hline
           		\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{publishTracingService(}BaseAgent
					applicantAgent, String serviceName, String description\textbf{)}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{publishTracingService(}AgentID
					tms\_aid, BaseAgent applicantAgent, String serviceName, String
					description\textbf{)}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{unpublishTracingService(}BaseAgent
					applicantAgent, String serviceName\textbf{)}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{unpublishTracingService(}AgentID
					tms\_aid, BaseAgent applicantAgent, String serviceName\textbf{)}}}\\ \hline \hline
           		\textbf{\texttt{tms\_aid}:} &  \texttt{AgentID} of the Trace Manager which will process the
					request. If not specified, the request is directed to the default Trace
					Manager, \texttt{TM}.\\ \hline
			\textbf{\texttt{applicantAgent}:} & Agent which is publishing the tracing service. \\ \hline
           		\textbf{\texttt{serviceName}:}  & String identifying the tracing service which is
					being published or unpublished.\\ \hline
           		\textbf{\texttt{description}:} & Human readable description of the tracing service
					which is being published.\\ \hline
       		\end{tabular}
%       }
       		}
   		\end{table}
		
		An example of tracing service publication can be:
		
		\begin{lstlisting}
publishTracingService(this, "TracingService_1", "An example of tracing service");
		\end{lstlisting}
		
		where the running agent (\texttt{this}) publishes a tracing service called \textit{TracingService\_1}
		which is described as \textit{An example of tracing service}. Once the running agent is done
		sharing these trace events, it can unpublish the tracing service by invoking the corresponding
		method referring to the already published tracing service:
		
		\begin{lstlisting}
unpublishTracingService(this, "TracingService_1");
		\end{lstlisting}
		
		\subsubsection{Tracing service subscription}\label{sec:subscription}
		
			Before receiving any trace event, agents have to request the corresponding tracing service
			by invoking \lstinline{requestTracingService}. This subscription can be cancelled later by
			invoking \lstinline{cancelTracingServiceSubscription}.
			
			It is also possible to subscribe to all available tracing services offered by any tracing entity in
			the system by invoking the method \lstinline{requestAllTracingServices}. The Trace Manager
			only alows for subcribing to all available has to be launched in monitorization mode. Thus,
			the following code would not work and the requester agent would receive a \texttt{REFUSE}
			ACL message with an \texttt{AUTHORIZATION\_ERROR} error code:
			
			\begin{lstlisting}
TraceManager tm = new TraceManager(new AgentID("TM"));

/* More code here... */

/* This will NOT work */
requestAllTracingServices(this);
			\end{lstlisting}
			
			Launching the Trace Manager with the monitorization flag set to true, like in the example,
			would do the job:
			
			\begin{lstlisting}
TraceManager tm = new TraceManager(new AgentID("TM"), true);

/* More code here... */

/* This will work */
requestAllTracingServices(this);
			\end{lstlisting}
			
			All these methods related to the subscription and unsubscription processes are described in
			more detail in Table \ref{tab:subscribe}.
			
		\begin{table}[ht]
     		\caption{Tracing service subscription and unsubscription methods}
       		\label{tab:subscribe}
       		\centerline{
%       \small{
       		\begin{tabular}{|r|p{11cm}|} \hline
           		\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{requestTracingService(}BaseAgent
					requesterAgent, String serviceName, AgentID originEntity\textbf{)}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{requestTracingService(}AgentID
					tms\_aid, BaseAgent requesterAgent, String serviceName, AgentID
					originEntity\textbf{)}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{requestTracingService(}BaseAgent
					requesterAgent, String serviceName\textbf{)}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{requestTracingService(}AgentID
					tms\_aid, BaseAgent requesterAgent, String serviceName\textbf{)}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{requestAllTracingServices(}BaseAgent
					requesterAgent\textbf{)}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{requestAllTracingServices(}AgentID
					tms\_aid, BaseAgent requesterAgent\textbf{)}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{cancelTracingServiceSubscription(}BaseAgent
					requesterAgent, String serviceName, AgentID originEntity\textbf{)}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{cancelTracingServiceSubscription(}AgentID
					tms\_aid, BaseAgent requesterAgent, String serviceName, AgentID
					originEntity\textbf{)}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{cancelTracingServiceSubscription(}BaseAgent
					requesterAgent, String serviceName\textbf{)}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{cancelTracingServiceSubscription(}AgentID
					tms\_aid, BaseAgent requesterAgent, String serviceName\textbf{)}}}\\ \hline \hline
           		\textbf{\texttt{tms\_aid}:} &  \texttt{AgentID} of the Trace Manager which will process the
					request. If not specified, the request is directed to the default Trace Manager,
					\texttt{TM}.\\ \hline
			\textbf{\texttt{requesterAgent}:} & Agent which is subscribing/unsubscribing to the tracing
					service. \\ \hline
           		\textbf{\texttt{serviceName}:}  & String identifying the tracing service to which the request
					refers.\\ \hline
           		\textbf{\texttt{originEntity}:} & \texttt{AgentID} of the specific agent which offers the tracing
					service. If not specified, the subscription/unsubscription request is considered to
					refer to tracing services offered by any tracing entity in the system.\\ \hline
       		\end{tabular}
%       }
       		}
   		\end{table}
			
			An example of tracing service subscription can be found in Section \ref{sec:daddy}, in line
			number 20, where the agent subscribes to the \textit{NEW\_AGENT} tracing service. Line
			number 68 also shows an example of subscription to a tracing service called
			\textit{MESSAGE\_SENT\_DETAIL} offered by a specific origin entity. Later in that source
			code, in lines 74 and 75, it can be observed how the agent unsubscribes from these tracing
			services.
			
		\subsubsection{Listing}\label{sec:listing}
		
			The Trace Manager allows for listing tracing entities and tracing services available in the
			system by invoking \lstinline{listTracingEntities} and \lstinline{listTracingServices}
			respectively. These two methods are described in more detail in Table \ref{tab:listing}.
		
			In response to any of these requests, a list of available tracing entities or available tracing
			services will be sent to the \texttt{applicantAgent} as an \texttt{AGREE} ACL message. The
			requested list will be included in the \texttt{content} field of the ACL message.
			
			When a list of avalable tracing entities has been requested, the \texttt{content} of the reply
			message will be structured as follows:
			
			\begin{itemize}
				\item Message content:\\
					$list\#entities\#<number\ of\ t\ entities>\#<t\ entity\ description\ list>$
				\item $<$\texttt{t entity description list}$>$: List of concatenated tracing entity
					descriptions, each of which is structured as follows:\\
					$\#<entity\ type>\#<entity\ identifier\ length>\#<entity\ identifier>$
				\item $<$\texttt{entity type}$>$: $\{0, 1, 2\}$ (meaning agent, artifact or
					aggregation)
			\end{itemize}
			
			When a list of tracing services has been requested, the \texttt{content} of the reply message
			will be structured as follows:
			
			\begin{itemize}
				\item Message content:\\
					$list\#services\#<number\ of\ t\ services>\#<t\ service\ description\ list>$
				\item $<$\texttt{t service description list}$>$: List of concatenated tracing service
					descriptions, each of which is structured as follows:\\
					$\#<service\ name\ length>\#<service\ name>\#<service\ description\ \\length>\#<service\ description>$
					\end{itemize}
					
		\begin{table}[ht]
     		\caption{Tracing services and tracing entities listing methods}
       		\label{tab:listing}
       		\centerline{
%       \small{
       		\begin{tabular}{|r|p{11cm}|} \hline
           		\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{listTracingEntities(}BaseAgent
					requesterAgent\textbf{)}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{listTracingEntities(}AgentID
					tms\_aid, BaseAgent requesterAgent\textbf{)}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{listTracingServices(}BaseAgent
					requesterAgent\textbf{)}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{listTracingServices(}AgentID
					tms\_aid, BaseAgent requesterAgent\textbf{)}}}\\ \hline \hline
           		\textbf{\texttt{tms\_aid}:} &  \texttt{AgentID} of the Trace Manager which will process the
					request. If not specified, the request is directed to the default Trace Manager,
					\texttt{TM}.\\ \hline
			\textbf{\texttt{requesterAgent}:} & Agent which is requesting the list of available tracing
					entities and services. \\ \hline
       		\end{tabular}
%       }
       		}
   		\end{table}

	\subsection{Domain Independent Tracing Services}
	
			The platform offers a set of \textit{domain independent} tracing services. Some of them can
			be requested by agents in order to receive the corresponding trace events, while others are
			not requestable and the corresponding trace events are received even without having
			requested them previously (this can be seen as a \textit{default subscription} to the tracing
			service). The rest of the section will describe them as well as how to interpret their
			correspoding trace events, according to the \texttt{TraceEvent} class and its attributes,
			previously described in Section \ref{sec:tEvent}. Domain independent tracing services can
			be classified in four main groups: System, agent's lifecycle, messaging and tracing service
			publication. These tracing services are included in the class
			\lstinline{es.upv.dsic.gti_ia.coreTracingService}

		\subsubsection{System domain independent tracing services}
		
			System domain independent tracing services provide information which may be necessary
			for any tracing entity in order to understand the sequence of trace events which it has
			received. These tracing services are not requestable and thus, trace events are received by
			tracing entities as they excute, without having previously subscribed to them. For instance, if
			a tracing service were not available anymore, all those agents which had previously
			requested it, would receive an \lstinline{UNAVAILABLE_TS} trace event, so that these
			agents know that the service is not being offered anymore. Details on system domain
			independent tracing services and on the information which their events provide are detailed
			in Table \ref{tab:system}.

%%%%%%%%%% ORIGINAL %%%%			
%%		\begin{table}[h!t]
%%     		\caption{System related domain independent tracing services}
%%       		\label{tab:system}
%%       		\centerline{
%%%       \small{
%%       		\begin{tabular}{|r|p{10cm}|} \hline
%%           		\textbf{Tracing Service Name} &  \textbf{Trace Event Description}\\ \hline
%%			\textbf{\texttt{TRACE\_ERROR:}} & Generic non determined error in the tracing
%%							process.
%%							\begin{itemize}
%%								\item \textbf{\texttt{tService}}: \texttt{TRACE\_ERROR} (0).
%%								\item \textbf{\texttt{originEntity}}: \texttt{system@host}.
%%								\item \textbf{\texttt{content}}: Human-readable error description.
%%							\end{itemize}
%%				\\ \hline
%%			\textbf{\texttt{SUBSCRIBE}:} & The tracing entity requested a tracing service with
%%							name \texttt{tServiceName} to an ES entity (\texttt{ESid}), which can be
%%							\texttt{any} to express interest in trace events of that tracing service coming
%%							from any of ES entities. From that time, trace events of that tracing service
%%							may be delivered to the tracing entity.
%%							\begin{itemize}
%%								\item \textbf{\texttt{tService}}: \texttt{SUBSCRIBE} (1).
%%								\item \textbf{\texttt{originEntity}}: Trace Manager entity to which the tracing
%%									service request was made.
%%								\item \textbf{\texttt{content}}: \lstinline{tServiceName\#tServiceDescription.length()\#tServicedescription\#ESid} (\texttt{ESid} can be \texttt{any}).
%%							\end{itemize} \\ \hline
%%			\textbf{\texttt{UNSUBSCRIBE}:} & The tracing entity cancelled the subscription to a
%%							tracing service (\texttt{tServiceName}) coming from the ES entity \texttt{ESid},
%%							which can be \texttt{any} if the removed subscription referred to trace events
%%							coming from any ES entity which provided it.
%%							\begin{itemize}
%%								\item \textbf{\texttt{tService}}: \texttt{UNSUBSCRIBE} (2).
%%								\item \textbf{\texttt{originEntity}}: Trace Manager entity to which the tracing
%%								service request was made.
%%								\item \textbf{\texttt{content}}: \lstinline{tServiceName\#ESid} (\texttt{ESid} can
%%								be \texttt{any}).
%%							\end{itemize} \\ \hline
%%			\textbf{\texttt{UNAVAILABLE\_TS}:} & The specified tracing service
%%							\texttt{ServiceName} is no longer available. This can be the consecuence of
%%							the origin entity which provided the tracing service terminating its own
%%							execution or unpublishing the tracing service. It also can be a consecuence
%%							of changes in the authorization graph of the tracing service. Receiving this
%%							trace event implies unsubscription from the tracing service, but no
%%							\texttt{UNSUBSCRIBE} trace event is expected.
%%							\begin{itemize}
%%								\item \textbf{\texttt{tService}}: \texttt{UNAVAILABLE\_TS} (3).
%%								\item \textbf{\texttt{originEntity}}: \texttt{system@host}.
%%								\item \textbf{\texttt{content}}: \texttt{tServiceName\#ESid} (\texttt{ESid} can be
%%									\texttt{any}).
%%							\end{itemize} \\ \hline
%%       		\end{tabular}
%%%       }
%%       		}
%%   		\end{table}

		\begin{table}[h!t]
     		\caption{System related domain independent tracing services}
       		\label{tab:system}
       		\centerline{
%       \small{
       		\begin{tabular}{|r|p{10cm}|} \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{TRACE\_ERROR:}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{Generic non determined error in the tracing process.}\\ \hline
           		\textbf{\texttt{tService}:} & \texttt{TRACE\_ERROR} (0)\\ \hline
			\textbf{\texttt{originEntity}:} & \texttt{system@host}\\ \hline
			\textbf{\texttt{content}:} & Human-readable error description.\\ \hline \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{SUBSCRIBE:}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{The tracing entity requested a tracing
						service with name \texttt{tServiceName} to an ES entity (\texttt{ESid}), which can
						be \texttt{any} to express interest in trace events of that tracing service coming
						from any of ES entities. From that time, trace events of that tracing service
						may be delivered to the tracing entity.}\\ \hline
           		\textbf{\texttt{tService}:} & \texttt{SUBSCRIBE} (1)\\ \hline
			\textbf{\texttt{originEntity}:} & Trace Manager entity to which the tracing service request was
						made.\\ \hline
			\textbf{\texttt{content}:} & \lstinline{tServiceName\#tServiceDescription.length()\#tServicedescription\#ESid} (\texttt{ESid} can be \texttt{any}).\\ \hline \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{UNSUBSCRIBE:}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{The tracing entity cancelled the
						subscription to a tracing service (\texttt{tServiceName}) coming from the ES entity
						\texttt{ESid}, which can be \texttt{any} if the removed subscription referred to trace
						events coming from any ES entity which provided it.}\\ \hline
           		\textbf{\texttt{tService}:} & \texttt{UNSUBSCRIBE} (2)\\ \hline
			\textbf{\texttt{originEntity}:} & Trace Manager entity to which the tracing service request was
						made.\\ \hline
			\textbf{\texttt{content}:} & \lstinline{tServiceName\#ESid} (\texttt{ESid} can be
						\texttt{any}).\\ \hline \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{UNAVAILABLE\_TS:}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{The specified tracing service
							\texttt{ServiceName} is no longer available. This can be the consecuence of
							the origin entity which provided the tracing service terminating its own
							execution or unpublishing the tracing service. It also can be a consecuence
							of changes in the authorization graph of the tracing service. Receiving this
							trace event implies unsubscription from the tracing service, but no
							\texttt{UNSUBSCRIBE} trace event is expected.}\\ \hline
           		\textbf{\texttt{tService}:} & \texttt{UNAVAILABLE\_TS} (3)\\ \hline
			\textbf{\texttt{originEntity}:} & \texttt{system@host}\\ \hline
			\textbf{\texttt{content}:} &  \texttt{tServiceName\#ESid} (\texttt{ESid} can be \texttt{any}).\\ \hline
       		\end{tabular}
%       }
       		}
   		\end{table}
		
		\subsubsection{Agent's lifecycle domain independent tracing services}
		
			These domain independent tracing services provide tracing information related to agents
			entering or leaving the system. These tracing services are requestable and thus, it is
			necessary to subscribe to them before receiving any trace event they may provide. An
			example of use of these tracing services can be observed in Section \ref{sec:daddy}, in line
			number 20. The daddy agent requests the tracing service \lstinline{NEW_AGENT} in order to
			receive a trace event each time a new agent enters the system. These events are later
			processed in the event handler, in line number 67.
			
			More details on these tracing services and on how to understand the information provided by
			these trace events are available in Table \ref{tab:lifecycle}.
		
		%%% ORIGINAL %%%%%
%%		\begin{table}[h!t]
%%     		\caption{Agent's lifecycle related domain independent tracing services}
%%       		\label{tab:lifecycle}
%%       		\centerline{
%%%       \small{
%%       		\begin{tabular}{|r|p{10cm}|} \hline
%%           		\textbf{Tracing Service Name} &  \textbf{Trace Event Description}\\ \hline
%%			\textbf{\texttt{NEW\_AGENT:}} & A new agent (\texttt{AgentId}), executing in a host
%%							(\texttt{host}) was registered in the system.
%%							\begin{itemize}
%%								\item \textbf{\texttt{tService}}: \texttt{NEW\_AGENT} (4)
%%								\item \textbf{\texttt{originEntity}}: \texttt{system@host}
%%								\item \textbf{\texttt{content}}: \texttt{AgentId}
%%							\end{itemize} \\ \hline
%%			\textbf{\texttt{AGENT\_DESTROYED}:} & An agent (\texttt{AgentId}), executing in a
%%							host (\texttt{host}) was destroyed.
%%							\begin{itemize}
%%								\item \textbf{\texttt{tService}}: \texttt{AGENT\_DESTROYED} (5)
%%								\item \textbf{\texttt{originEntity}}: \texttt{system@host}
%%								\item \textbf{\texttt{content}}: \texttt{AgentId}
%%							\end{itemize} \\ \hline
%%       		\end{tabular}
%%%       }
%%       		}
%%   		\end{table}
		
		\begin{table}[h!t]
     		\caption{Agent's lifecycle related domain independent tracing services}
       		\label{tab:lifecycle}
       		\centerline{
%       \small{
       		\begin{tabular}{|r|p{10cm}|} \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{NEW\_AGENT:}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{A new agent (\texttt{AgentId}),
						executing in a host (\texttt{host}) was registered in the system.}\\ \hline
           		\textbf{\texttt{tService}:} & \texttt{NEW\_AGENT} (4)\\ \hline
			\textbf{\texttt{originEntity}:} & \texttt{system@host}\\ \hline
			\textbf{\texttt{content}:} & \texttt{AgentId}\\ \hline \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{AGENT\_DESTROYED:}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{An agent (\texttt{AgentId}),
						executing in a host (\texttt{host}) was destroyed.}\\ \hline
           		\textbf{\texttt{tService}:} & \texttt{AGENT\_DESTROYED} (5)\\ \hline
			\textbf{\texttt{originEntity}:} & \texttt{system@host}\\ \hline
			\textbf{\texttt{content}:} & \texttt{AgentId}\\ \hline
       		\end{tabular}
%       }
       		}
   		\end{table}
		
		\subsubsection{Messaging related domain independent tracing services}
		
			These domain independent tracing services provide information related to message based
			agent communication. These tracing services are also requestable and thus, it is also
			necessary to subscribe to them before receiving any trace event they may provide. An
			example of use of these tracing services can be observed in Section \ref{sec:daddy}, in line
			number 68, where the daddy agent requests a tracing service called
			\lstinline{MESSAGE_SENT_DETAIL} in order to inspect every message that his boy agents,
			Bobby or Timmy, send.
			
			More details on these tracing services and on how to understand the information provided by
			these trace events are available in Table \ref{tab:messaging}.
	
%%%%%%%% ORIGINAL %%%%%%%%%%%	
%		\begin{table}[h!t]
%     		\caption{Agent's messaging related domain independent tracing services}
%       		\label{tab:messaging}
%       		\centerline{
%%       \small{
%       		\begin{tabular}{|r|p{10cm}|} \hline
%           		\textbf{Tracing Service Name} &  \textbf{Trace Event Description}\\ \hline
%			\textbf{\texttt{MESSAGE\_SENT:}} & A FIPA-ACL message was sent from
%							\texttt{OriginAgentId} to \texttt{DestinationAgentId}.
%							\begin{itemize}
%								\item \textbf{\texttt{tService}}: \texttt{MESSAGE\_SENT} (6)
%								\item \textbf{\texttt{originEntity}}: \texttt{OriginAgentId}.
%								\item \textbf{\texttt{content}}: \texttt{DestinationAgentId}
%							\end{itemize} \\ \hline
%			\textbf{\texttt{MESSAGE\_SENT\_DETAIL}:} & A FIPA-ACL message was sent
%							from \texttt{OriginAgentId}. The difference with \texttt{MESSAGE\_SENT} is
%							that \texttt{MESSAGE\_SENT\_DETAIL} trace events include the ACL
%							message they refer to.
%							\begin{itemize}
%								\item \textbf{\texttt{tService}}: \texttt{MESSAGE\_SENT\_DETAIL} (7)
%								\item \textbf{\texttt{originEntity}}: \texttt{OriginAgentId}
%								\item \textbf{\texttt{content}}: \texttt{SerializedMessage}
%							\end{itemize} \\ \hline
%			\textbf{\texttt{MESSAGE\_RECEIVED}:} & A FIPA-ACL message was received by
%							\texttt{DestinationAgentId} from \texttt{OriginAgentId}.
%							\begin{itemize}
%								\item \textbf{\texttt{tService}}: \texttt{MESSAGE\_RECEIVED} (8).
%								\item \textbf{\texttt{originEntity}}: \texttt{DestinationAgentId}
%								\item \textbf{\texttt{content}}: \texttt{OriginAgentId}
%							\end{itemize} \\ \hline
%			\textbf{\texttt{MESSAGE\_RECEIVED\_DETAIL}:} & A FIPA-ACL message was
%							received by \texttt{DestinationAgentId}. The difference with
%							\texttt{MESSAGE\_RECEIVED} is that
%							\texttt{MESSAGE\_RECEIVED\_DETAIL} trace events include the ACL
%							message they refer to.
%							\begin{itemize}
%								\item \textbf{\texttt{tService}}: \texttt{MESSAGE\_RECEIVED\_DETAIL} (9)
%								\item \textbf{\texttt{originEntity}}: \texttt{DestinationAgentId}
%								\item \textbf{\texttt{content}}: \texttt{SerializedMessage}
%							\end{itemize} \\ \hline
%       		\end{tabular}
%%       }
%       		}
%   		\end{table}
		
		\begin{table}[h!t]
     		\caption{Agent's messaging related domain independent tracing services}
       		\label{tab:messaging}
       		\centerline{
%       \small{
       		\begin{tabular}{|r|p{10cm}|} \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{MESSAGE\_SENT:}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{A FIPA-ACL message was sent from
						\texttt{OriginAgentId} to \texttt{DestinationAgentId}.}\\ \hline
           		\textbf{\texttt{tService}:} & \texttt{MESSAGE\_SENT} (6)\\ \hline
			\textbf{\texttt{originEntity}:} & \texttt{OriginAgentId}\\ \hline
			\textbf{\texttt{content}:} & \texttt{DestinationAgentId}\\ \hline \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{MESSAGE\_SENT\_DETAIL:}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{A FIPA-ACL message was sent
						from \texttt{OriginAgentId}. The difference with \texttt{MESSAGE\_SENT} is
						that \texttt{MESSAGE\_SENT\_DETAIL} trace events include the ACL
						message they refer to.}\\ \hline
           		\textbf{\texttt{tService}:} & \texttt{MESSAGE\_SENT\_DETAIL} (7)\\ \hline
			\textbf{\texttt{originEntity}:} & \texttt{OriginAgentId}\\ \hline
			\textbf{\texttt{content}:} & \texttt{SerializedMessage}\\ \hline \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{MESSAGE\_RECEIVED:}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{A FIPA-ACL message was
						received by \texttt{DestinationAgentId}.}\\ \hline
           		\textbf{\texttt{tService}:} & \texttt{MESSAGE\_RECEIVED} (8)\\ \hline
			\textbf{\texttt{originEntity}:} & \texttt{DestinationAgentId}\\ \hline
			\textbf{\texttt{content}:} & \texttt{OriginAgentId}\\ \hline \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{MESSAGE\_RECEIVED\_DETAIL:}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{A FIPA-ACL message was
							received by \texttt{DestinationAgentId}. The difference with
							\texttt{MESSAGE\_RECEIVED} is that
							\texttt{MESSAGE\_RECEIVED\_DETAIL} trace events include the ACL
							message they refer to.}\\ \hline
           		\textbf{\texttt{tService}:} & \texttt{MESSAGE\_RECEIVED\_DETAIL} (9)\\ \hline
			\textbf{\texttt{originEntity}:} & \texttt{DestinationAgentId}\\ \hline
			\textbf{\texttt{content}:} &  \texttt{SerializedMessage}\\ \hline
       		\end{tabular}
%       }
       		}
   		\end{table}
		
		\subsubsection{Tracing service publication related domain independent tracing services}
		
			These domain independent tracing services provide information related to tracing services
			being published by tracing entities in the system. For instance, a generic agent may need to
			be noticed when a specific tracing service is being offered or when another agent is not
			sharing certain tracing information anymore. These domain independent tracing services
			and the information they provide are detailed in Table \ref{tab:pub}
	
%%%%%%%%%% ORIGINAL %%%%%%		
%%		\begin{table}[h!t]
%%     		\caption{Tracing service publication related domain independent tracing services}
%%       		\label{tab:pub}
%%       		\centerline{
%%%       \small{
%%       		\begin{tabular}{|r|p{10cm}|} \hline
%%           		\textbf{Tracing Service Name} &  \textbf{Trace Event Description}\\ \hline
%%			\textbf{\texttt{PUBLISHED\_TRACING\_SERVICE:}} & A tracing service
%%							\texttt{ServiceName} was published by the tracing entity \texttt{ESId}.
%%							\begin{itemize}
%%								\item \textbf{\texttt{tService}}: \texttt{PUBLISHED\_TRACING\_SERVICE} (10).
%%								\item \textbf{\texttt{originEntity}}: \texttt{ESId}
%%								\item \textbf{\texttt{content}}: \texttt{ServiceName}
%%							\end{itemize} \\ \hline
%%			\textbf{\texttt{UNPUBLISHED\_TRACING\_SERVICE}:} & A tracing service
%%							\texttt{ServiceName} was unpublished by the tracing entity \texttt{ESId}.
%%							\begin{itemize}
%%								\item \textbf{\texttt{tService}}: \texttt{UNPUBLISHED\_TRACING\_SERVICE} (11).
%%								\item \textbf{\texttt{originEntity}}: \texttt{ESId}
%%								\item \textbf{\texttt{content}}: \texttt{ServiceName}
%%							\end{itemize} \\ \hline
%%       		\end{tabular}
%%%       }
%%       		}
%%   		\end{table}

\begin{table}[h!t]
     		\caption{Tracing service publication related domain independent tracing services}
       		\label{tab:pub}
       		\centerline{
%       \small{
       		\begin{tabular}{|r|p{10cm}|} \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{PUBLISHED\_TRACING\_SERVICE:}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{A tracing service
						\texttt{ServiceName} was published by the tracing entity \texttt{ESId}}\\ \hline
           		\textbf{\texttt{tService}:} & \texttt{PUBLISHED\_TRACING\_SERVICE} (10)\\ \hline
			\textbf{\texttt{originEntity}:} & \texttt{ESId}\\ \hline
			\textbf{\texttt{content}:} & \texttt{ServiceName}\\ \hline \hline
			\multicolumn{2}{|p{14cm}|}{\texttt{\textbf{UNPUBLISHED\_TRACING\_SERVICE:}}}\\ \hline
			\multicolumn{2}{|p{14cm}|}{A tracing service \texttt{ServiceName} was unpublished by the
						tracing entity \texttt{ESId}.}\\ \hline
           		\textbf{\texttt{tService}:} & \texttt{UNPUBLISHED\_TRACING\_SERVICE} (11)\\ \hline
			\textbf{\texttt{originEntity}:} & \texttt{ESId}\\ \hline
			\textbf{\texttt{content}:} & \texttt{ServiceName}\\ \hline
       		\end{tabular}
%       }
       		}
   		\end{table}
	
\subsection{Example: TraceDaddy}
		
	Simple example of how to use domain independent tracing services to follow other
	agents' activities and to make decisions according to this activity.
    			
	In this case, a Daddy agent listens to his sons (Boy agents) while they are playing and when
	one of them starts crying, he proposes them to take them to the park. When both children
	agree, daddy and his sons leave the building and the application finishes.
    			
	\begin{itemize}
		\item\textbf{Initialization:}
			\begin{itemize}
				\item DADDY:\\
					Requests to the NEW\_AGENT tracing service in order to know when
					children arrive.\\
					Prints on screen that he intends to read the newspaper.
							
				\item BOYS (Bobby and Timmy):\\
					Print on screen their name and age.
			\end{itemize}
					
		\item\textbf{Execution:}
			\begin{itemize}
				\item DADDY:\\
					Each time a NEW\_AGENT event is received, Daddy requests the tracing
					service MESSAGE\_SENT\_DETAIL in order to 'listen' to what that agent
					says.\\
					Each time a MESSAGE\_SENT\_DETAIL trace event is received, Daddy
					prints its content on screen and checks if the content of the message is equal
					to 'GUAAAAAA!'. If so, Daddy cancels the subscription to
					MESSAGE\_SENT\_DETAIL tracing services and sends ACL request 
					messages to both children to propose the go to the park.\\
					When both childre have replied with an AGREE message, Daddy agent
					prints it on screen and ends its execution.
					
				\item BOYS (Bobby and Timmy):\\
					Bobby, which is only 5, sends each second an ACL request message to
					Timmy (which is 7) to request him his toy (Give me your toy). After 5 denials,
					Bobby starts requesting it by crying (sending an ACL message with a loud
					GUAAAAAA!).\\
					Both Boy agents reply NO! to any request which does not come from their
					father and only AGREE when their dad requests them to GO TO THE
					PARK.\\
					When dad requests them (via an ACL message) to go to the park, both sons
					agree and end their execution.
			\end{itemize}
	\end{itemize}
	
	\subsection{\texttt{Daddy} class}\label{sec:daddy}
			
		\begin{lstlisting}
package TraceDaddy;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;

import es.upv.dsic.gti_ia.core.ACLMessage;
import es.upv.dsic.gti_ia.core.AgentID;
import es.upv.dsic.gti_ia.core.BaseAgent;
import es.upv.dsic.gti_ia.core.TraceEvent;
import es.upv.dsic.gti_ia.trace.TraceInteract;

public class Daddy extends BaseAgent{
   private boolean finish=false;
   private boolean Bobby_agree=false;
   private boolean Timmy_agree=false;
	
   public Daddy(AgentID aid) throws Exception{
      super(aid);
      TraceInteract.requestTracingService(this, "NEW_AGENT");
      System.out.println("[Daddy " + this.getName() + "]: I want to read the newspaper...");
   }
	
   public void execute(){
      ACLMessage msg;
      while(!finish){
         try {
            Thread.sleep(1000);
         } catch (InterruptedException e) {
            e.printStackTrace();
         }
         
         System.out.println("[Daddy " + this.getName() + "]: Ok! I give up... Shall we go to the park?");
		
         msg = new ACLMessage(ACLMessage.REQUEST);
         msg.setSender(this.getAid());
         msg.setContent("GO TO THE PARK");
         msg.setReceiver(new AgentID("Timmy"));
         send(msg);
         msg.setReceiver(new AgentID("Bobby"));
         send(msg);
         while(!Bobby_agree || !Timmy_agree){
            try {
               Thread.sleep(1000);
            } catch (InterruptedException e) {
               e.printStackTrace();
            }
         }
         
         try {
            Thread.sleep(1000);
         } catch (InterruptedException e) {
            e.printStackTrace();
         }
         
         System.out.println("[Daddy " + this.getName() + "]: Ok! Let's go, children!");
      }
      
      public void onTraceEvent(TraceEvent tEvent) {
         DateFormat formatter = new SimpleDateFormat("HH:mm:ss.SSS");
         
         Calendar calendar = Calendar.getInstance();
         calendar.setTimeInMillis(tEvent.getTimestamp());
         
         ACLMessage msg;
         
         if (tEvent.getTracingService().contentEquals("NEW_AGENT")){
            TraceInteract.requestTracingService(this, "MESSAGE_SENT_DETAIL", new AgentID(tEvent.getContent()));
         }
         else if (tEvent.getTracingService().contentEquals("MESSAGE_SENT_DETAIL")){
            msg = ACLMessage.fromString(tEvent.getContent());
            System.out.println("[" + this.getName() + " " + formatter.format(calendar.getTime()) + "]: " + msg.getSender().toString() + " said: " + msg.getPerformative() + ": " + msg.getContent());
            if (msg.getContent().contentEquals("GUAAAAAA..!")){
               TraceInteract.cancelTracingServiceSubscription(this, "MESSAGE_SENT_DETAIL",new AgentID("Timmy"));
               TraceInteract.cancelTracingServiceSubscription(this, "MESSAGE_SENT_DETAIL",new AgentID("Bobby"));
               finish=true;
            }
         }
      }
      
      public void onMessage(ACLMessage msg){
         if((msg.getPerformativeInt() == ACLMessage.AGREE) && (msg.getContent().contentEquals("GO TO THE PARK"))){
            System.out.println("[Daddy " + this.getName() + "]: " + msg.getSender().name + " says: " + msg.getPerformative() + " " + msg.getContent());
            if (msg.getSender().getLocalName().contentEquals("Bobby")){
               Bobby_agree=true;
            }
            
            if (msg.getSender().getLocalName().contentEquals("Timmy")){
               Timmy_agree=true;
            }
         }
      }
   }
		\end{lstlisting}
		
	\subsection{\texttt{Boy} class}\label{sec:boy}
		
		\begin{lstlisting}
package TraceDaddy;

import es.upv.dsic.gti_ia.core.ACLMessage;
import es.upv.dsic.gti_ia.core.AgentID;
import es.upv.dsic.gti_ia.core.BaseAgent;

public class Boy extends BaseAgent {
   private int age;
   private boolean finish=false;
   AgentID dad;

   public Boy (AgentID aid, int age, AgentID dad) throws Exception{
      super(aid);
      this.age=age;
      this.dad=dad;
      System.out.println("[" + this.getName() + "]: I'm " + this.getName() + " and I'm "+ this.age + " years old!");
   }
	
   public void execute(){
      ACLMessage msg;
      int counter=5;
      while(!finish){
         if (this.age <= 5) {
            msg = new ACLMessage(ACLMessage.REQUEST);
            msg.setSender(this.getAid());
            if (counter > 0){
               msg.setContent("Give me your toy...");
            }
            else{
               msg.setContent("GUAAAAAA..!");
            }
            counter--;
            
            msg.setReceiver(new AgentID("qpid://Timmy@localhost:8080"));
            send(msg);
         }
         try {
            Thread.sleep(1000);
         } catch (InterruptedException e) {
            e.printStackTrace();
         }
      }
   }
	
   public void onMessage(ACLMessage msg){
      if (msg.getSender().getLocalName().contentEquals(dad.getLocalName())){
         // Daddy!
         if(msg.getPerformativeInt() == ACLMessage.REQUEST){
            if (msg.getContent().contentEquals("GO TO THE PARK")){
               finish=true;
               ACLMessage response_msg = new ACLMessage(ACLMessage.AGREE);
               response_msg.setSender(this.getAid());
               response_msg.setContent("GO TO THE PARK");
               response_msg.setReceiver(msg.getSender());
               send(response_msg);
            }
         }
      }
      else{
         // You no daddy!
         if(msg.getPerformativeInt() == ACLMessage.REQUEST){
            ACLMessage response_msg = new ACLMessage(ACLMessage.REFUSE);
            response_msg.setSender(this.getAid());
            response_msg.setContent("NO!");
            response_msg.setReceiver(msg.getSender());
            send(response_msg);
         }
      }
   }
}
		\end{lstlisting}
		
	\subsection{Main application source code}\label{sec:mainapp}
		
		\begin{lstlisting}
package TraceDaddy;

import org.apache.log4j.Logger;
import org.apache.log4j.xml.DOMConfigurator;

import es.upv.dsic.gti_ia.core.AgentID;
import es.upv.dsic.gti_ia.core.AgentsConnection;
import es.upv.dsic.gti_ia.trace.TraceManager;

public class Run {
   public static void main(String[] args) {
      Boy olderSon, youngerSon;
      Daddy dad;
      /**
       * Setting the Logger
       */
      DOMConfigurator.configure("configuration/loggin.xml");
      Logger logger = Logger.getLogger(Run.class);
      
      /**
       * Connecting to Qpid Broker
       */
      AgentsConnection.connect();
      
      try {
         /**
          * Instantiating the Trace Manager
          */
         TraceManager tm = new TraceManager(new AgentID("TM"));
         
         System.out.println("INITIALIZING...");
         
         /**
          * Instantiating Dad
          */
         dad = new Daddy(new AgentID("qpid://MrSmith@localhost:8080"));
         
         /**
          * Instantiating sons
          */
         olderSon = new Boy(new AgentID("qpid://Timmy@localhost:8080"), 7, dad.getAid());
         youngerSon = new Boy(new AgentID("qpid://Bobby@localhost:8080"), 5, dad.getAid());
         
         /**
          * Execute the agents
          */
         dad.start();
         olderSon.start();
         youngerSon.start();
      } catch (Exception e) {
         logger.error("Error  " + e.getMessage());
      }
   }
}
		\end{lstlisting}
		
	\subsection{Results}
		
%		\begin{lstlisting}
		\begin{codigo}
INITIALIZING...
[Daddy MrSmith]: I want to read the newspaper...
[Timmy]: I'm Timmy and I'm 7 years old!
[Bobby]: I'm Bobby and I'm 5 years old!
[MrSmith 16:11:06.077]: qpid://Timmy@localhost:8080
	said: REFUSE: NO!
[MrSmith 16:11:07.072]: qpid://Bobby@localhost:8080
	said: REQUEST: Give me your toy...
[MrSmith 16:11:07.077]: qpid://Timmy@localhost:8080
	said: REFUSE: NO!
[MrSmith 16:11:08.075]: qpid://Bobby@localhost:8080
	said: REQUEST: Give me your toy...
[MrSmith 16:11:08.080]: qpid://Timmy@localhost:8080
	said: REFUSE: NO!
[MrSmith 16:11:09.077]: qpid://Bobby@localhost:8080
	said: REQUEST: Give me your toy...
[MrSmith 16:11:09.083]: qpid://Timmy@localhost:8080
	said: REFUSE: NO!
[MrSmith 16:11:10.080]: qpid://Bobby@localhost:8080
	said: REQUEST: Give me your toy...
[MrSmith 16:11:10.094]: qpid://Timmy@localhost:8080
	said: REFUSE: NO!
[MrSmith 16:11:11.082]: qpid://Bobby@localhost:8080
	said: REQUEST: GUAAAAAA..!
[MrSmith 16:11:11.087]: qpid://Timmy@localhost:8080
	said: REFUSE: NO!
[Daddy MrSmith]: Ok! I give up... Shall we go to the park?
[Daddy MrSmith]: Timmy says: AGREE GO TO THE PARK
[Daddy MrSmith]: Bobby says: AGREE GO TO THE PARK
[Daddy MrSmith]: Ok! Let's go, children!
		\end{codigo}
%		\end{lstlisting}


